/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.launcher3;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
//add by zhouerlong
import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.app.Activity;
import android.app.WallpaperManager;
import android.content.ComponentName;
//add by zhouerlong
import android.content.Context;
import android.content.pm.ResolveInfo;//add by zhouerlong
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.Region.Op;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.os.Handler;
import android.os.SystemClock;
import android.support.v4.widget.AutoScrollHelper;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.util.TypedValue;
import android.view.ActionMode;
import android.view.Display;
//add by zhouerlong
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.MeasureSpec;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.AnimationSet;
import android.view.animation.Interpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.ImageView;
//add by zhouerlong
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;

import com.android.gallery3d.util.LogUtils;
import com.android.launcher3.FolderInfo.FolderListener;
import com.android.launcher3.FolderInfo.State;
import com.android.launcher3.anim.LauncherFolderAnimations;
import com.android.launcher3.anim.TransitionAnims.TransitionListener;
import com.android.launcher3.notify.PreferencesManager;
import com.android.launcher3.tsearch.MyViewPagerAdapter;
import com.android.launcher3.view.LauncherBackgroudView;
import com.mediatek.launcher3.ext.LauncherLog;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class HideAppView extends LinearLayout implements DragSource,
		View.OnClickListener, View.OnLongClickListener, DropTarget,
		FolderListener, TextView.OnEditorActionListener,
		View.OnFocusChangeListener {
	private static final String TAG = "Launcher.Folder";

	protected DragController mDragController;

//	private LauncherBackgroudView mWallpaperView;// M by xxf

	// add by zhouerlong begin 20150814
	private Handler mHandler = new Handler();
	// add by zhouerlong end 20150814
	protected Launcher mLauncher;
	protected FolderInfo mInfo;
	private boolean successfulDrop = true;

	static final int STATE_NONE = -1;
	static final int STATE_SMALL = 0;
	static final int STATE_ANIMATING = 1;
	static final int STATE_OPEN = 2;
	// add by zhouerlong
	// add by zhouerlong
	private final float SCANLE_ANIM_MI = 0.18f;
	private final float SCANLE_LAUNCHERBC_MAX = 5.2f;
	private final float WALL_SCALE = 1.1f;
	private final float SCANLE_ANIM_MAX = 0.85f;
	// add by zhouerlong

	private int mExpandDuration;
	protected CellLayout mContent;

	ArrayList<ShortcutInfo> mContents = new ArrayList<ShortcutInfo>();
	ArrayList<ShortcutInfo> mSelects = new ArrayList<ShortcutInfo>();
	// add by zhouerlong begin 20150814
	ArrayList<ShortcutInfo> mLastSelects = new ArrayList<ShortcutInfo>();
	// add by zhouerlong begin 20150814
	ArrayList<ComponentName> mComponentNames = new ArrayList<ComponentName>();
	// add by zhouerlong
	private ScrollView mScrollView;
	private final LayoutInflater mInflater;
	private final IconCache mIconCache;
	private int mState = STATE_NONE;
	private Interpolator mZoomInInterpolator = new DecelerateInterpolator();
	private static final int DURATION_OPEN_CLOSE = 1000;
	private static final int REORDER_ANIMATION_DURATION = 530;
	private static final int REORDER_DELAY = 250;
	private static final int ON_EXIT_CLOSE_DELAY = 800;
	private boolean mRearrangeOnClose = false;

	int[] from = new int[2];
	int[] to = new int[2];
	private FitSystemWindow mLauncherBackground;// M by xxf
	private int mMaxCountX;
	private View mOtherView;
	private View mOtherView1;
	// add by zhouerlong
	private int mMaxCountY;
	private int mMaxNumItems;
	private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
	
	private VisibleAppsView mVisibleAppsView;
	private Drawable mIconDrawable;
	boolean mItemsInvalidated = false;
	private ShortcutInfo mCurrentDragInfo;
	private View mCurrentDragView;
	boolean mSuppressOnAdd = false;
	private int[] mTargetCell = new int[2];
	private int[] mPreviousTargetCell = new int[2];
	private int[] mEmptyCell = new int[2];
	private Alarm mReorderAlarm = new Alarm();
	private Alarm mOnExitAlarm = new Alarm();
	private int mFolderNameHeight;
	private Rect mTempRect = new Rect();
	private boolean mDragInProgress = false;
	private boolean mDeleteFolderOnDropCompleted = false;
	private boolean mSuppressFolderDeletion = false;
	private boolean mItemAddedBackToSelfViaIcon = false;
	FolderEditText mFolderName;
	private float mFolderIconPivotX;
	private float mFolderIconPivotY;

	private boolean mIsEditingName = false;
	private InputMethodManager mInputMethodManager;

	private static String sDefaultFolderName;
	private static String sHintText;

	private int DRAG_MODE_NONE = 0;
	private int DRAG_MODE_REORDER = 1;
	private int mDragMode = DRAG_MODE_NONE;

	private boolean mDestroyed;

	private AutoScrollHelper mAutoScrollHelper;

	private Runnable mDeferredAction;
	private boolean mDeferDropAfterUninstall;
	private boolean mUninstallSuccessful;

	private View mMoreView;

	/**
	 * Used to inflate the Workspace from XML.
	 * 
	 * @param context
	 *            The application's context.
	 * @param attrs
	 *            The attribtues set containing the Workspace's customization
	 *            values.
	 */
	public HideAppView(Context context, AttributeSet attrs) {
		super(context, attrs);

		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		setAlwaysDrawnWithCacheEnabled(false);
		mInflater = LayoutInflater.from(context);
		mIconCache = app.getIconCache();

		Resources res = getResources();
		// add by zhouerlong
		mMaxCountX = 4;// (int) grid.numColumns;
		mMaxCountY = 40;// (int) grid.numRows;
		// add by zhouerlong
		mMaxNumItems = mMaxCountX * mMaxCountY;

		mInputMethodManager = (InputMethodManager) getContext()
				.getSystemService(Context.INPUT_METHOD_SERVICE);

		mExpandDuration = 200;

		if (sDefaultFolderName == null) {
			sDefaultFolderName = res.getString(R.string.folder_name);
		}
		if (sHintText == null) {
			sHintText = res.getString(R.string.folder_hint_text);
		}
		mLauncher = (Launcher) context;
		// We need this view to be focusable in touch mode so that when text
		// editing of the folder
		// name is complete, we have something to focus on, thus hiding the
		// cursor and giving
		// reliable behvior when clicking the text field (since it will always
		// gain focus on click).
		setFocusableInTouchMode(true);
	}

	/**
	 * 过滤在文件夹里面删除的
	 * 
	 * @param lasts
	 *            默认的图标集合
	 * @param targets
	 *            编辑后的图标集合
	 * @return
	 */
	List<ShortcutInfo> filterdelete(List<ShortcutInfo> lasts,
			List<ShortcutInfo> targets) {
		List<ShortcutInfo> filters = new ArrayList<>();
		for (ShortcutInfo info : lasts) {
			if (lasts.contains(info) && !targets.contains(info)) {
				filters.add(info);
			}
		}
		return filters;
	}

	public void bindHideWorkspaceItem(ShortcutInfo info) {
		Workspace work = mLauncher.getworkspace();

    	View v = work.getViewForComponentName(info.intent.getComponent());
		ShortcutInfo item =(ShortcutInfo) v.getTag();
		item.hide=1;
		work.removeViewByComponentName(v);
		LauncherModel.modifyItemInDatabaseByHide(mContext, item);
		
		
	}
	
	

	public void onDropShortExternal(final Object dargInfo, View v) {
		onDropShortExternal(dargInfo, mContent, false, 500, v);
	}
	
	public void onDropShortExternal(final Object dragInfo,
			final CellLayout cellLayout, boolean insertAtFirst, final int duration,
			final View v) {
		

		// This is for other drag/drop cases, like dragging from All Apps
		View shotview = null;

		ItemInfo info = (ItemInfo) dragInfo;
		// onDrop(info, true);
		if (successfulDrop == false) {
			return;
		}
		successfulDrop = false;
		switch (info.itemType) {
		case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
		case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
			if (info.container == NO_ID && info instanceof AppInfo) {
				// Came from all apps -- make a copy
				info = new ShortcutInfo((AppInfo) info);
			}
			shotview = mLauncher.createShortcut(R.layout.application,
					cellLayout, (ShortcutInfo) info);
			break;
		case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
			shotview = FolderIcon.fromXml(R.layout.folder_icon, mLauncher,
					cellLayout, (FolderInfo) info, mIconCache);
			break;
		default:
			throw new IllegalStateException("Unknown item type: "
					+ info.itemType);
		}
		mTargetCell[0] = 0;
		mTargetCell[1] = 0;
		int spanX = info.spanX;
		int spanY = info.spanY;
		int x = 0;
		int y = 0;
		ViewGroup.LayoutParams genericLp = v.getLayoutParams();
		CellLayout.LayoutParams lp;
		if (genericLp == null
				|| !(genericLp instanceof CellLayout.LayoutParams)) {
			lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
		} else {
			lp = (CellLayout.LayoutParams) genericLp;
			lp.cellX = mTargetCell[0];
			lp.cellY = mTargetCell[1];
			lp.cellHSpan = spanX;
			lp.cellVSpan = spanY;
		}
		ShortcutInfo shotviewInfo = (ShortcutInfo) shotview.getTag();
		shotviewInfo.cellX = lp.cellX;
		shotviewInfo.cellY = lp.cellY;
		shotviewInfo.spanX = lp.cellHSpan;
		shotviewInfo.spanY = lp.cellVSpan;
//		realTimeReorder(info, true);
		mContent.getLastNewPosition(mEmptyCell);
		
		shotview.setOnClickListener(this);
		mContent.addViewToCellLayout(shotview, -1, -1, lp, true);
		cellLayout.onDropChild(shotview);
		CellLayout.LayoutParams lps = (CellLayout.LayoutParams) shotview
				.getLayoutParams();
		cellLayout.getShortcutsAndWidgets().measureChild(shotview);
		/*
		 * LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container,
		 * screenId, lp.cellX, lp.cellY);
		 */
		DragView dragView = createDragView(v);
		if (v instanceof PagedViewIcon) {
			dragView = this.createDragView(v);
			// 修改这里表示如果是编辑模式的app 的话就将编辑界面 apps 选项的位置提供 否则应该是文件夹分解 如果不加这里 会发现
			// 如果文件夹分解的时候会出现文件夹图标向下面移动 而不是 分解后的app icons
		}
		final View shortView = shotview;
		final Runnable exitSpringLoadedRunnable = new Runnable() {
			@Override
			public void run() {
				successfulDrop = true;
				mContent.markCellsAsOccupiedForView(shortView);
				if(!findAndSetEmptyCells()) {
					setupContentForNumItems(getItemCount()+1);
				}
//				mVisibleAppsView.setupContentDimensions(mVisibleAppsView.getItemCount());
				
				mVisibleAppsView.realTimeReorderWithDelete();
				ShortcutInfo shot = (ShortcutInfo) v.getTag();
				bindHideWorkspaceItem(shot);
			}
		};
//		if(getItemCount()<=1) {
			dragView.showNoAnimation(dragView.getDragRegionLeft(),
					dragView.getDragRegionTop());
			mVisibleAppsView.getLayout().removeView(v);
			if (dragView != null) {
				// We wrap the animation call in the temporary set and reset of
				// the current
				// cellLayout to its final transform -- this means we animate
				// the drag view to
				// the correct final location.
				mLauncher.getDragLayer().animateViewIntoPosition(dragView,
						shortView, exitSpringLoadedRunnable, -1, duration, true,
						null);// widget or apps
//			}
		}
		
		final Runnable realReorderLOadedRunnable = new Runnable() {
			
			@Override
			public void run() {}
		};

		realTimeReorder(mEmptyCell, mTargetCell,null);
		

	}
	
	

	public static final int DRAG_BITMAP_PADDING = 2;
	
	
	public DragView createDragView(View child) {

        final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);

        final int bmpWidth = b.getWidth();
        final int bmpHeight = b.getHeight();
        int loc[] = new int[2]; 
       float scale= mLauncher.getDragLayer().getLocationInDragLayer(child, loc);
        
        
        int dragLayerX =
                Math.round(loc[0] - (bmpWidth - scale * child.getWidth()) / 2);
        int dragLayerY =
                Math.round(loc[1] - (bmpHeight - scale * bmpHeight) / 2
                        - DRAG_BITMAP_PADDING / 2);
        

        int top = child.getPaddingTop();
        dragLayerY += top;
        int dragLeft =dragLayerX;
        int dragTop=dragLayerY;
        
        
        return   new DragView(mLauncher, b, dragLeft,
        		dragTop, 0, 0, b.getWidth(), b.getHeight(), scale);//修改启动点位置
    }
	
	/**
	 * Returns a new bitmap to show when the given View is being dragged around.
	 * Responsibility for the bitmap is transferred to the caller.
	 */
	public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
		Bitmap b;

		if (v instanceof TextView) {
			Drawable d = ((TextView) v).getCompoundDrawables()[1];
			/*
			 * b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
			 * d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
			 */
			 if(Launcher.isSupportIconSize) {
	                b=ImageUtils.drawableToBitmap1(d);
	            }else {
	            	b=Utilities.createIconBitmap(d, mContext);
	            }
		} else {
			b = Bitmap.createBitmap(v.getWidth() + padding, v.getHeight()
					+ padding, Bitmap.Config.ARGB_8888);
		}

		canvas.setBitmap(b);
		drawDragView(v, canvas, padding, true);
		canvas.setBitmap(null);

		return b;
	}
	
	/**
	 * Draw the View v into the given Canvas.
	 * 
	 * @param v
	 *            the view to draw
	 * @param destCanvas
	 *            the canvas to draw on
	 * @param padding
	 *            the horizontal and vertical padding to use when drawing
	 */
	private void drawDragView(View v, Canvas destCanvas, int padding,
			boolean pruneToDrawable) {
		final Rect clipRect = new Rect();
		v.getDrawingRect(clipRect);

		boolean textVisible = false;

		destCanvas.save();
		if (v instanceof TextView && pruneToDrawable) {
			Drawable d = ((TextView) v).getCompoundDrawables()[1];
			clipRect.set(0, 0, d.getIntrinsicWidth() + padding,
					d.getIntrinsicHeight() + padding);
			destCanvas.translate(padding / 2, padding / 2);
			d.draw(destCanvas);
		} else {
			if (v instanceof FolderIcon) {
				// For FolderIcons the text can bleed into the icon area, and so
				// we need to
				// hide the text completely (which can't be achieved by
				// clipping).
				if (((FolderIcon) v).getTextVisible()) {
					((FolderIcon) v).setTextVisible(false);
					textVisible = true;
				}
			} else if (v instanceof BubbleTextView) {
				final BubbleTextView tv = (BubbleTextView) v;
				clipRect.bottom = tv.getExtendedPaddingTop()
						- (int) BubbleTextView.PADDING_V
						+ tv.getLayout().getLineTop(0);
			} else if (v instanceof TextView) {
				final TextView tv = (TextView) v;
				clipRect.bottom = tv.getExtendedPaddingTop()
						- tv.getCompoundDrawablePadding()
						+ tv.getLayout().getLineTop(0);
			}
			destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY()
					+ padding / 2);
			destCanvas.clipRect(clipRect, Op.REPLACE);
			v.draw(destCanvas);

			// Restore text visibility of FolderIcon if necessary
			if (textVisible) {
				((FolderIcon) v).setTextVisible(true);
			}
		}
		destCanvas.restore();
	}
	
	public void addMoreIcon() {


		LayoutInflater inflater = LayoutInflater.from(mContext);
		 mMoreView =inflater.inflate(R.layout.more_icon_edit, null);
		if (parent.indexOfChild(mMoreView) !=-1) {
			return; 
		}
		DragLayer.LayoutParams lp = new DragLayer.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
		lp.customPosition = true;
		LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        lp.width = grid.iconSizePx-grid.iconSizePx/3;
        lp.height = grid.iconSizePx-grid.iconSizePx/3;
        View    hot= mLauncher.getHotseat();
        Rect r = new Rect();
        parent.getDescendantRectRelativeToSelf(hot,r);
        Display display = ((Activity) this.getContext()).getWindowManager().getDefaultDisplay();
        int x =(display.getWidth()-lp.width)/2;
        int y = r.top;
        lp.x = (int) x;
        lp.y = (int) r.top;
//        mMoreView.setLayoutParams(lp);
        mMoreView.bringToFront();
        mMoreView.setScaleX(0f);
        mMoreView.setScaleY(0f);
//        if (!AppsCustomizePagedView.DISABLE_ALL_APPS) {
          parent.addView(mMoreView,lp);
//        }
          
          
        mMoreView.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View arg0) {
//				mLauncher.getVisibleView().animateOpen();
			}
		});
	}
	
	public View getMoreView() {
		return mMoreView;
	}
	
	private void visibleMoreIcon(boolean visible) {
		float from = visible ? 0f : 1f;
		float to = 1f - from;
		
		ValueAnimator scale = ObjectAnimator.ofFloat(from, to);
		scale.addUpdateListener(new AnimatorUpdateListener() {

			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = (float) animation.getAnimatedValue();
//				 mContent.setAlpha(255*value);
				mMoreView.setScaleX(value);
				mMoreView.setScaleY(value);
			}
		});
		if (visible)
			scale.setStartDelay(100);
		scale.start();
	}

	@Override
	protected void onFinishInflate() {
		super.onFinishInflate();
		mScrollView = (ScrollView) findViewById(R.id.scroll_view);
		mContent = (CellLayout) findViewById(R.id.folder_content);
//		mWallpaperView = (LauncherBackgroudView) mLauncher
//				.findViewById(R.id.launcher_bg);
		mLauncherBackground = (FitSystemWindow) mLauncher
				.findViewById(R.id.workspaceAndOther);

		// add by zhouerlong

		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();

		mContent.setCellDimensions(grid.folderCellWidthPx,
				grid.folderCellHeightPx);
		mContent.setGridSize(0, 0);
		mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
		mContent.setInvertIfRtl(true);
		mFolderName = (FolderEditText) findViewById(R.id.folder_name);
		mFolderName.setOnFocusChangeListener(this);

		// We find out how tall the text view wants to be (it is set to
		// wrap_content), so that
		// we can allocate the appropriate amount of space for it.
		int measureSpec = MeasureSpec.UNSPECIFIED;
		mFolderName.measure(measureSpec, measureSpec);
		mFolderNameHeight = mFolderName.getMeasuredHeight();

		// We disable action mode for now since it messes up the view on phones
		mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
		mFolderName.setOnEditorActionListener(this);
		mFolderName.setSelectAllOnFocus(true);
		mFolderName.setInputType(mFolderName.getInputType()
				| InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
				| InputType.TYPE_TEXT_FLAG_CAP_WORDS);
		mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);
	}

	private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
		public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
			return false;
		}

		public boolean onCreateActionMode(ActionMode mode, Menu menu) {
			return false;
		}

		public void onDestroyActionMode(ActionMode mode) {
		}

		public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
			return false;
		}
	};
	
	

	@Override
	public void onClick(View v) {
			Object tag = v.getTag();
			
			if(mVisibleAppsView.getParent() == null) {
	       if (tag instanceof ShortcutInfo) {
	            mLauncher.onClick(v);
	            return;
	        }
			}

			ShortcutInfo info = (ShortcutInfo) tag;
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v
					.getLayoutParams();
			mEmptyCell[0] = lp.cellX;
			mEmptyCell[1] = lp.cellY;
			mContent.getLastPosition(mTargetCell);
			mVisibleAppsView.onDropShortExternal(tag, v);
	        
	}
	
	
	

	public boolean onLongClick(View v) {
		// Return if global dragging is not enabled
		if (!mLauncher.isDraggingEnabled())
			return true;

		Object tag = v.getTag();
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "onLongClick: v = " + v + ", tag = " + tag);
		}

		if (tag instanceof ShortcutInfo) {
			ShortcutInfo item = (ShortcutInfo) tag;
			if (!v.isInTouchMode()) {
				return false;
			}

			mLauncher.dismissFolderCling(null);

			mLauncher.getWorkspace().onDragStartedWithItem(v);
			mLauncher.getWorkspace().beginDragShared(v, this);
			mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

			mCurrentDragInfo = item;
			mEmptyCell[0] = item.cellX;
			mEmptyCell[1] = item.cellY;
			mCurrentDragView = v;

			mContent.removeView(mCurrentDragView);
			mInfo.remove(mCurrentDragInfo, State.NORMAL);
			mDragInProgress = true;
			mItemAddedBackToSelfViaIcon = false;
		}
		return true;
	}

	public boolean isEditingName() {
		return mIsEditingName;
	}

	public void startEditingFolderName() {
		mFolderName.setHint("");
		mIsEditingName = true;
	}

	public void dismissEditingName() {
		mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
		doneEditingFolderName(true);
	}

	public void doneEditingFolderName(boolean commit) {
		// / M: [ALPS01250799] Get correct folder hint string before setting
		// hint.
		sHintText = getResources().getString(R.string.folder_hint_text);
		mFolderName.setHint(sHintText);
		// Convert to a string here to ensure that no other state associated
		// with the text field
		// gets saved.
		String newTitle = mFolderName.getText().toString();
		mInfo.setTitle(newTitle);
		LauncherModel.updateItemInDatabase(mLauncher, mInfo);

		if (commit) {
			sendCustomAccessibilityEvent(
					AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
					String.format(
							getContext().getString(R.string.folder_renamed),
							newTitle));
		}
		// In order to clear the focus from the text field, we set the focus on
		// ourself. This
		// ensures that every time the field is clicked, focus is gained, giving
		// reliable behavior.
		requestFocus();

		Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
		mIsEditingName = false;
	}

	public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
		if (actionId == EditorInfo.IME_ACTION_DONE) {
			dismissEditingName();
			return true;
		}
		return false;
	}

	public View getEditTextRegion() {
		return mFolderName;
	}

	public Drawable getDragDrawable() {
		return mIconDrawable;
	}

	/**
	 * We need to handle touch events to prevent them from falling through to
	 * the workspace below.
	 */
	@Override
	public boolean onTouchEvent(MotionEvent ev) {
		return true;
	}

	public void setDragController(DragController dragController) {
		mDragController = dragController;
	}

	@Override
	public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
		// When the folder gets focus, we don't want to announce the list of
		// items.
		return true;
	}

	/**
	 * @return the FolderInfo object associated with this folder
	 */
	FolderInfo getInfo() {
		return mInfo;
	}

	private class GridComparator implements Comparator<ShortcutInfo> {
		int mNumCols;

		public GridComparator(int numCols) {
			mNumCols = numCols;
		}

		@Override
		public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
			int lhIndex = lhs.cellY * mNumCols + lhs.cellX;
			int rhIndex = rhs.cellY * mNumCols + rhs.cellX;
			return (lhIndex - rhIndex);
		}
	}

	private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
		int maxX = 0;
		int count = items.size();
		for (int i = 0; i < count; i++) {
			ShortcutInfo item = items.get(i);
			if (item.cellX > maxX) {
				maxX = item.cellX;
			}
		}

		GridComparator gridComparator = new GridComparator(maxX + 1);
		Collections.sort(items, gridComparator);
		final int countX = mContent.getCountX();
		for (int i = 0; i < count; i++) {
			int x = i % countX;
			int y = i / countX;
			ShortcutInfo item = items.get(i);
			item.cellX = x;
			item.cellY = y;
		}
	}

	void setAllApps(List<ShortcutInfo> apps) {
		mContent.removeAllViews();
		mContents.clear();
		setupContentForNumItems(apps.size());

		for (ShortcutInfo info : apps) {

			if (createAndAddShortcut(info)) {
				mContents.addAll(apps);
			}
		}

		setupContentForNumItems(mContents.size());

	}
	

	private boolean isDowanLoad(ShortcutInfo shortcutInfo) {
		return (shortcutInfo.flags & AppInfo.DOWNLOADED_FLAG) != 0;
	}
	 void bindAllApps(List<AppInfo> apps) {
		mContent.removeAllViews();
		mContents.clear();
		setupContentForNumItems(apps.size());
		for (AppInfo appInfo : apps) {
			ShortcutInfo info = new ShortcutInfo(appInfo);

			if(isDowanLoad(info)) {
				if(info.hide==1) {
					if (createAndAddShortcut(info)) {
						mContents.add(info);
					}
				}
			}
		}

		setupContentForNumItems(mContents.size());

	}

	public ArrayList<ShortcutInfo> getContents() {
		return mContents;
	}

	void bind(FolderInfo info) {
		mInfo = info;
		mComponentNames = info.getComponentNames();
		mSelects.clear();
		mLastSelects.clear();
		/* mSelects.addAll(info.contents); */

		/*
		 * ArrayList<ShortcutInfo> children = info.contents;
		 * ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
		 * setupContentForNumItems(children.size());
		 * placeInReadingOrder(children); int count = 0; for (int i = 0; i <
		 * children.size(); i++) { ShortcutInfo child = (ShortcutInfo)
		 * children.get(i); createAndAddShortcut(child); }
		 */
	}

	/**
	 * Creates a new UserFolder, inflated from R.layout.user_folder.
	 * 
	 * @param context
	 *            The application's context.
	 * 
	 * @return A new UserFolder.
	 */
	static HideAppView fromXml(Context context) {
		return (HideAppView) LayoutInflater.from(context).inflate(
				R.layout.hide_apps_view, null);
	}

	/**
	 * This method is intended to make the UserFolder to be visually identical
	 * in size and position to its associated FolderIcon. This allows for a
	 * seamless transition into the expanded state.
	 */
	private void positionAndSizeAsIcon() {
		if (!(getParent() instanceof DragLayer))
			return;
		setScaleX(1f);
		setScaleY(1f);
		/* setAlpha(0f); */
		// add by zhouerlong

		mState = STATE_SMALL;
	}

	// add by zhouerlong

	public void animateOpen(int x, int y) {
		if (!(getParent() instanceof DragLayer))
			return;
		WallpaperManager wm = WallpaperManager.getInstance(mLauncher);
		// mWallpaperView.setLauncherBg(wm.getFastDrawable());
		// mWallpaperView.invalidate();
		centerAboutIcon(from, to, x, y);
		addMoreIcon();
		this.setAlpha(1f);

		LauncherFolderAnimations mFolderAnimator = new LauncherFolderAnimations(
				mZoomInInterpolator);
		int fromX = 0;
		int fromY = 0;
		int toX = to[0] - from[0];
		int toY = to[1] - from[1];

		/*
		 * int contentAreaWidthSpec =
		 * MeasureSpec.makeMeasureSpec(mContent.getDesiredWidth(),
		 * MeasureSpec.EXACTLY); int contentAreaHeightSpec =
		 * MeasureSpec.makeMeasureSpec(getContentAreaHeight(),
		 * MeasureSpec.EXACTLY); mScrollView.measure(contentAreaWidthSpec,
		 * contentAreaHeightSpec); this.requestLayout();
		 */
//		mScrollView.setBackground(mLauncher.getDrawable(R.drawable.folder_cell_bg1));
		mFolderAnimator.play(this,
				new float[] { SCANLE_ANIM_MI, SCANLE_ANIM_MI }, new float[] {
						0.9f, 0.9f }, from, to);
//		mFolderAnimator.play(mWallpaperView, new float[] { 1f, 1f },
//				new float[] { WALL_SCALE, WALL_SCALE });
		mFolderAnimator.play(mLauncherBackground, new float[] { 1f, 1f },
				new float[] { SCANLE_LAUNCHERBC_MAX, SCANLE_LAUNCHERBC_MAX },
				new float[] { fromX, fromY }, new float[] {
						toX * SCANLE_LAUNCHERBC_MAX,
						toY * SCANLE_LAUNCHERBC_MAX }, 0f);
		mFolderAnimator.setListener(new TransitionListener() {

			public void onTransitionStart(Animator animator, Animation animation) {
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, String
								.format(getContext().getString(
										R.string.folder_opened),
										mContent.getCountX(),
										mContent.getCountY()));
				mState = STATE_ANIMATING;
				mLauncherBackground.setLayerType(LAYER_TYPE_HARDWARE, null);
//				mFolderName.setAlpha(0f);
				setVisibility(View.VISIBLE);
//				mWallpaperView.setVisibility(View.VISIBLE);

			}

			public void onTransitionEnd(Animator animator, Animation animation) {
				mState = STATE_OPEN;
				setLayerType(LAYER_TYPE_NONE, null);
				mLauncherBackground.setLayerType(LAYER_TYPE_NONE, null);
				updateContentUnreadNum();
				setFocusOnFirstChild();

				visibleMoreIcon(true);
			}
		});
		mFolderAnimator.setDuration(DURATION_OPEN_CLOSE);
		mFolderAnimator.setInterpolator(mZoomInInterpolator);
		mFolderAnimator.start();
	}

	/**
	 * M: Update unread number of the content shortcut.
	 */
	public void updateContentUnreadNum() {
		if (LauncherLog.DEBUG_UNREAD) {
			LauncherLog.d(TAG, "Folder updateContentUnreadNum: mInfo = "
					+ mInfo);
		}
		ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer) mContent
				.getShortcutsAndWidgets();
		int childCount = container.getChildCount();
		for (int i = 0; i < childCount; i++) {
			BubbleTextView shortcut = (BubbleTextView) container.getChildAt(i);
			if (shortcut != null) {
				shortcut.invalidate();
			}
		}
	}

	private void sendCustomAccessibilityEvent(int type, String text) {
		AccessibilityManager accessibilityManager = (AccessibilityManager) getContext()
				.getSystemService(Context.ACCESSIBILITY_SERVICE);
		if (accessibilityManager.isEnabled()) {
			AccessibilityEvent event = AccessibilityEvent.obtain(type);
			onInitializeAccessibilityEvent(event);
			event.getText().add(text);
			accessibilityManager.sendAccessibilityEvent(event);
		}
	}

	private void setFocusOnFirstChild() {
		View firstChild = mContent.getChildAt(0, 0);
		if (firstChild != null) {
			firstChild.requestFocus();
		}
	}

	class AnimationOther extends AnimatorListenerAdapter {

		@Override
		public void onAnimationEnd(Animator animation) {
			// TODO Auto-generated method stub
			super.onAnimationEnd(animation);

		}

	}
	
	
	public void closeHideView() {

		if (mVisibleAppsView.getAnimationingState() != STATE_ANIMATING
				&& getAnimationingState() != STATE_ANIMATING) {
			animateClosed();
		}
	}

	/**
	 * 文件夹关闭动画
	 */
	public void animateClosed() {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "animateClosed: parent = " + getParent());
		}
		if (!(getParent() instanceof DragLayer))
			return;

		int toX = 0;
		int toY = 0;
		int fromX = (int) ((to[0] - from[0]) * SCANLE_LAUNCHERBC_MAX);
		int fromY = (int) ((to[1] - from[1]) * SCANLE_LAUNCHERBC_MAX);

		LauncherFolderAnimations mFolderAnimator = new LauncherFolderAnimations(
				mZoomInInterpolator);

		mFolderAnimator.play(this, new float[] { 1f, 1f }, new float[] {
				SCANLE_ANIM_MI, SCANLE_ANIM_MI }, to, from);
//		mFolderAnimator.play(mWallpaperView, new float[] { WALL_SCALE,
//				WALL_SCALE }, new float[] { 1f, 1f });
		mFolderAnimator.play(mLauncherBackground, new float[] {
				SCANLE_LAUNCHERBC_MAX, SCANLE_LAUNCHERBC_MAX }, new float[] {
				1f, 1f }, new float[] { fromX, fromY },
				new float[] { toX, toY }, 1f);
		mFolderAnimator.setListener(new TransitionListener() {

			@Override
			public void onTransitionStart(Animator animator, Animation animation) {
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
						getContext().getString(R.string.folder_closed));
				mState = STATE_ANIMATING;
				mLauncherBackground.setLayerType(LAYER_TYPE_HARDWARE, null);
//				mWallpaperView.setVisibility(View.VISIBLE);
//				mFolderName.setAlpha(0f);
				visibleMoreIcon(false);
			}

			@Override
			public void onTransitionEnd(Animator animator, Animation animation) {
				onCloseComplete();
				setLayerType(LAYER_TYPE_NONE, null);
				mLauncherBackground.setLayerType(LAYER_TYPE_NONE, null);
				mState = STATE_SMALL;

//				mWallpaperView.setVisibility(View.GONE);
				mLauncher.showWorkspaceSearchAndHotseat();
				if(parent.indexOfChild(mMoreView) !=-1) {
					parent.removeView(mMoreView);
				}
				expandWorkspaceAndHotseat();

			}
		});

		ValueAnimator alphaByThis = ObjectAnimator.ofFloat(1f, 0f);
		alphaByThis.addUpdateListener(new AnimatorUpdateListener() {

			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float percent = 1 - (float) animation.getAnimatedFraction();
				LogUtils.i(TAG, percent + "");
				if (percent <= 0.3) {
					setAlpha(percent);
				}

			}
		});

		mFolderAnimator.setDuration(DURATION_OPEN_CLOSE);
		mFolderAnimator.setInterpolator(mZoomInInterpolator);
		mFolderAnimator.getAnimatorSet().play(alphaByThis);
		mFolderAnimator.start();
	}

	private void expandWorkspaceAndHotseat() {
		PropertyValuesHolder scaleX = PropertyValuesHolder
				.ofFloat("scaleX", 1f);
		PropertyValuesHolder scaleY = PropertyValuesHolder
				.ofFloat("scaleY", 1f);
		final View parents = mLauncher.findViewById(R.id.workspaceAndOther);
		ObjectAnimator draglayer = LauncherAnimUtils.ofPropertyValuesHolder(
				parents, scaleX, scaleY);
		draglayer.setDuration(DURATION_OPEN_CLOSE);
		draglayer.start();
		draglayer.addListener(new AnimatorListenerAdapter() {
			@Override
			public void onAnimationStart(Animator animation) {

				parents.setLayerType(LAYER_TYPE_HARDWARE, null);
			}

			@Override
			public void onAnimationEnd(Animator animation) {

				parents.setLayerType(LAYER_TYPE_NONE, null);
			}
		});
	}

	// add by zhouerlong
	public boolean acceptDrop(DragObject d) {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "acceptDrop: DragObject = " + d);
		}

		final ItemInfo item = (ItemInfo) d.dragInfo;
		final int itemType = item.itemType;
		return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION || itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) && !isFull());
	}

	protected boolean findAndSetEmptyCells(ShortcutInfo item) {
		int[] emptyCell = new int[2];
		if (mContent.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
			item.cellX = emptyCell[0];
			item.cellY = emptyCell[1];
			return true;
		} else {
			return false;
		}
	}
	
	protected boolean findAndSetEmptyCells() {
		int[] emptyCell = new int[2];
		if (mContent.findCellForSpan(emptyCell, 1, 1)) {
			return true;
		} else {
			return false;
		}
	}

	protected boolean createAndAddShortcut(ShortcutInfo item) {
		final BubbleTextView textView = (BubbleTextView) mInflater.inflate(
				R.layout.application, this, false);
		// M by zhouerlong
		final ResolveInfo resolveInfo = this.mContext.getPackageManager()
				.resolveActivity(item.intent, 0);
		if (resolveInfo == null) {
			return false;
		}
		Launcher launcher = null;
		if (mContext instanceof Launcher) {
			launcher = (Launcher) mContext;
		}
		if(Launcher.isSupportIconSize) {
		textView.setCompoundDrawablesWithIntrinsicBounds(null,
				new FastBitmapDrawable(item.getIcon(mIconCache)), null,
				null);
		}else {
			textView.setCompoundDrawables(null,
			 Utilities.createIconDrawable(item.getIcon(mIconCache)), null, null);
		}
		textView.setText(item.title);
		textView.setTag(item);
		textView.setTextColor(getResources().getColor(
				R.color.folder_items_text_color));
		textView.setShadowsEnabled(false);
//		textView.setCompoundDrawablePadding((int) getResources().getDimension(
//				R.dimen.icon_drawable_padding));

		textView.setOnClickListener(this);

		// We need to check here to verify that the given item's location isn't
		// already occupied
		// by another item.
		if (mContent.getChildAt(item.cellX, item.cellY) != null
				|| item.cellX < 0 || item.cellY < 0
				|| item.cellX >= mContent.getCountX()
				|| item.cellY >= mContent.getCountY()) {
			// This shouldn't happen, log it.
			// Log.e(TAG, "Folder order not properly persisted during bind");
			if (!findAndSetEmptyCells(item)) {
				return false;
			}
		}

		CellLayout.LayoutParams lp = new CellLayout.LayoutParams(item.cellX,
				item.cellY, item.spanX, item.spanY);
		boolean insert = false;
		textView.setOnKeyListener(new FolderKeyEventListener());
		mContent.addViewToCellLayout(textView, insert ? 0 : -1, (int) item.id,
				lp, true);
		return true;
	}

	public void onDragEnter(DragObject d) {
		// add by zhouerlong
		mPreviousTargetCell[0] = -1;
		mPreviousTargetCell[1] = -1;
		mOnExitAlarm.cancelAlarm();
	}

	OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
		public void onAlarm(Alarm alarm) {
			realTimeReorder(mEmptyCell, mTargetCell,null);
		}
	};

	boolean readingOrderGreaterThan(int[] v1, int[] v2) {
		if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
			return true;
		} else {
			return false;
		}
	}
public void realTimeReorderWithDelete() {
		
		mReorderAlarm.cancelAlarm();
		mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
		mReorderAlarm.setAlarm(REORDER_DELAY);
	}
	private void realTimeReorder(int[] empty, int[] target,Runnable r) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int delay = 0;
        float delayAmount = 30;
        if (readingOrderGreaterThan(target, empty)) {
            wrap = empty[0] >= mContent.getCountX() - 1;//表示如果当前空的地方是否最右边也就是往下拖动
            startY = wrap ? empty[1] + 1 : empty[1];//true 往下移动一行开始，false 还是当前行 不会执行
            for (int y = startY; y <= target[1]; y++) {
                startX = y == empty[1] ? empty[0] + 1 : 0;//表示是往下拖动不在同一行  {y == empty[1]}true 就是同一行，fase就是下一行从0开始
                endX = y < target[1] ? mContent.getCountX() - 1 : target[0]; //{y < target[1]} true 表示有多行应该走到底 false 当前行
                for (int x = startX; x <= endX; x++) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true,r)) {
                        empty[0] = x;
                        empty[1] = y;//冒泡移动
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        } else {
            wrap = empty[0] == 0;
            startY = wrap ? empty[1] - 1 : empty[1];
            for (int y = startY; y >= target[1]; y--) {
                startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX() - 1;
                endX = y > target[1] ? 0 : target[0];
                for (int x = startX; x >= endX; x--) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true,r)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        }
    }

	public boolean isLayoutRtl() {
		return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
	}

	public void onDragOver(DragObject d) {
		final DragView dragView = d.dragView;
		final int scrollOffset = mScrollView.getScrollY();
		final float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset,
				d.yOffset, dragView, null);
		r[0] -= getPaddingLeft();
		r[1] -= getPaddingTop();

		final long downTime = SystemClock.uptimeMillis();
		final MotionEvent translatedEv = MotionEvent.obtain(downTime, downTime,
				MotionEvent.ACTION_MOVE, d.x, d.y, 0);

		if (!mAutoScrollHelper.isEnabled()) {
			mAutoScrollHelper.setEnabled(true);
		}

		final boolean handled = mAutoScrollHelper.onTouch(this, translatedEv);
		translatedEv.recycle();

		if (handled) {
			mReorderAlarm.cancelAlarm();
		} else {
			mTargetCell = mContent.findNearestArea((int) r[0], (int) r[1]
					+ scrollOffset, 1, 1, mTargetCell);
			if (isLayoutRtl()) {
				mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
			}
			if (mTargetCell[0] != mPreviousTargetCell[0]
					|| mTargetCell[1] != mPreviousTargetCell[1]) {
				mReorderAlarm.cancelAlarm();
				mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
				mReorderAlarm.setAlarm(REORDER_DELAY);
				mPreviousTargetCell[0] = mTargetCell[0];
				mPreviousTargetCell[1] = mTargetCell[1];
				mDragMode = DRAG_MODE_REORDER;
			} else {
				mDragMode = DRAG_MODE_NONE;
			}
		}
	}

	// This is used to compute the visual center of the dragView. The idea is
	// that
	// the visual center represents the user's interpretation of where the item
	// is, and hence
	// is the appropriate point to use when determining drop location.
	private float[] getDragViewVisualCenter(int x, int y, int xOffset,
			int yOffset, DragView dragView, float[] recycle) {
		float res[];
		if (recycle == null) {
			res = new float[2];
		} else {
			res = recycle;
		}

		// These represent the visual top and left of drag view if a dragRect
		// was provided.
		// If a dragRect was not provided, then they correspond to the actual
		// view left and
		// top, as the dragRect is in that case taken to be the entire dragView.
		// R.dimen.dragViewOffsetY.
		int left = x - xOffset;
		int top = y - yOffset;

		// In order to find the visual center, we shift by half the dragRect
		res[0] = left + dragView.getDragRegion().width() / 2;
		res[1] = top + dragView.getDragRegion().height() / 2;

		return res;
	}

	OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
		public void onAlarm(Alarm alarm) {
			completeDragExit();
		}
	};

	public int getAnimationingState() {
		return this.mState;
	}

	public void completeDragExit() {
		mLauncher.closeFolder();
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;
		mRearrangeOnClose = true;
	}

	public void onDragExit(DragObject d) {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "onDragExit: DragObject = " + d);
		}

		// Exiting folder; stop the auto scroller.
		mAutoScrollHelper.setEnabled(false);
		// add by zhouerlong
		// We only close the folder if this is a true drag exit, ie. not because
		// a drop has occurred above the folder.
		if (!d.dragComplete) {
			mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
			mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
		}
		mReorderAlarm.cancelAlarm();
		mDragMode = DRAG_MODE_NONE;
	}

	public void onDropCompleted(final View target, final DragObject d,
			final boolean isFlingToDelete, final boolean success) {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "onDropCompleted: View = " + target
					+ ", DragObject = " + d + ", isFlingToDelete = "
					+ isFlingToDelete + ", success = " + success);
		}

		if (mDeferDropAfterUninstall) {
			Log.d(TAG, "Deferred handling drop because waiting for uninstall.");
			mDeferredAction = new Runnable() {
				public void run() {
					onDropCompleted(target, d, isFlingToDelete, success);
					mDeferredAction = null;
				}
			};
			return;
		}

		boolean beingCalledAfterUninstall = mDeferredAction != null;
		boolean successfulDrop = success
				&& (!beingCalledAfterUninstall || mUninstallSuccessful);

		if (successfulDrop) {
			if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon) {
				replaceFolderWithFinalItem();
			}
		} else {
			setupContentForNumItems(getItemCount());
		}

		if (target != this) {
			if (mOnExitAlarm.alarmPending()) {
				mOnExitAlarm.cancelAlarm();
				if (!successfulDrop) {
					mSuppressFolderDeletion = true;
				}
				completeDragExit();
			}
		}

		mDeleteFolderOnDropCompleted = false;
		mDragInProgress = false;
		mItemAddedBackToSelfViaIcon = false;
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;

		// Reordering may have occured, and we need to save the new item
		// locations. We do this once
		// at the end to prevent unnecessary database operations.
		updateItemLocationsInDatabaseBatch();
	}

	public void deferCompleteDropAfterUninstallActivity() {
		mDeferDropAfterUninstall = true;
	}

	public void onUninstallActivityReturned(boolean success) {
		mDeferDropAfterUninstall = false;
		mUninstallSuccessful = success;
		if (mDeferredAction != null) {
			mDeferredAction.run();
		}
	}

	@Override
	public boolean supportsFlingToDelete() {
		return true;
	}

	public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
		// Do nothing
	}

	@Override
	public void onFlingToDeleteCompleted() {
		// Do nothing
	}

	private void updateItemLocationsInDatabase() {
		ArrayList<View> list = getItemsInReadingOrder();
		for (int i = 0; i < list.size(); i++) {
			View v = list.get(i);
			ItemInfo info = (ItemInfo) v.getTag();
			LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0,
					info.cellX, info.cellY);
		}
	}

	private void updateItemLocationsInDatabaseBatch() {
		ArrayList<View> list = getItemsInReadingOrder();
		ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
		for (int i = 0; i < list.size(); i++) {
			View v = list.get(i);
			ItemInfo info = (ItemInfo) v.getTag();
			if (info != null) {
				items.add(info);
			}
		}

		LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
	}

	public void addItemLocationsInDatabase() {
		ArrayList<View> list = getItemsInReadingOrder();
		for (int i = 0; i < list.size(); i++) {
			View v = list.get(i);
			ItemInfo info = (ItemInfo) v.getTag();
			LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0,
					info.cellX, info.cellY, false);
		}
	}

	public void notifyDrop() {
		if (mDragInProgress) {
			mItemAddedBackToSelfViaIcon = true;
		}
	}

	public boolean isDropEnabled() {
		return true;
	}

	// add by zhouerlong
	public void setupContentDimensions(int count) {
		final ArrayList<View> list = getItemsInReadingOrder();

		int countX = mContent.getCountX();
		int countY = mContent.getCountY();
		boolean done = false;

		while (!done) {
			int oldCountX = countX;
			int oldCountY = countY;
			if (countX * countY < count) {
				// Current grid is too small, expand it
				if (/* (countX <= countY || countY == mMaxCountY) && */countX < mMaxCountX) {
					countX++;
				} else if (countY < mMaxCountY && countY * countX < count) {
					countY++;
				}
				if (countY == 0)
					countY++;
			} else if ((countY - 1) * countX >= count /* && countY >= countX */) {
				countY = Math.max(0, countY - 1);
			} else if ((countX - 1) * countY >= count) {
				// countX = Math.max(0, countX - 1);
			}
			done = countX == oldCountX && countY == oldCountY;
		}
		countX = mMaxCountX;
		if(countY<mMaxCountX) {
			countY = mMaxCountX-1;
		}
		mContent.setGridSize(countX, countY);
		arrangeChildren(list);
	}

	/*
	 * private void setupContentDimensions(int count) { ArrayList<View> list =
	 * getItemsInReadingOrder();
	 * 
	 * int countX = mContent.getCountX(); int countY = mContent.getCountY();
	 * boolean done = false;
	 * 
	 * while (!done) { int oldCountX = countX; int oldCountY = countY; if
	 * (countX * countY < count) { // Current grid is too small, expand it if
	 * ((countX <= countY || countY == mMaxCountY) && countX < mMaxCountX) {
	 * countX++; } else if (countY < mMaxCountY) { countY++; } if (countY == 0)
	 * countY++; } else if ((countY - 1) * countX >= count && countY >= countX)
	 * { countY = Math.max(0, countY - 1); } else if ((countX - 1) * countY >=
	 * count) { countX = Math.max(0, countX - 1); } done = countX == oldCountX
	 * && countY == oldCountY; } mContent.setGridSize(countX, countY);
	 * arrangeChildren(list); }
	 */

	// add by zhouerlong
	public boolean isFull() {
		return getItemCount() >= mMaxNumItems;
	}

	private DragLayer parent;

	// add by zhouerlong
	private void centerAboutIcon(int[] from, int[] to, int x, int y) {
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

		parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
		int width = getPaddingLeft() + getPaddingRight()
				+ mContent.getDesiredWidth(); // 计算文件夹的宽高
		int height = getFolderHeight();
		this.getX();// this的坐标
		this.getY();// this的坐标

		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		int Left = x - width / 2;// 差值
		int Top = y - height / 2;// 差值
		from[0] = Left;
		from[1] = Top;
		int currentPage = mLauncher.getWorkspace().getNextPage();
		// In case the workspace is scrolling, we need to use the final scroll
		// to compute
		// the folders bounds.
		mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
		// We first fetch the currently visible CellLayoutChildren
		CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace()
				.getChildAt(currentPage);
		if (currentLayout == null) {
			return;
		}
		ShortcutAndWidgetContainer boundingLayout = currentLayout
				.getShortcutsAndWidgets();
		Rect bounds = new Rect();
		parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
		// We reset the workspaces scroll
		mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);

		Display display = ((Activity) this.getContext()).getWindowManager()
				.getDefaultDisplay();
		float wCenterX = (display.getWidth() - width) / 2;
		float wCenterY = (display.getHeight() - height) / 2; // add by
																// zhouerlong
																// 文件夹中心点偏上
																// 还原中心点
		to[0] = (int) wCenterX;
		to[1] = (int) wCenterY;

		int folderPivotX = (int) (mTempRect.left - wCenterX);
		int folderPivotY = (int) (mTempRect.top - wCenterY);
		lp.width = width;
		lp.height = height;
	}

	// add by zhouerlong
	float getPivotXForIconAnimation() {
		return mFolderIconPivotX;
	}

	float getPivotYForIconAnimation() {
		return mFolderIconPivotY;
	}

	void setupContentForNumItems(int count) {
		setupContentDimensions(count);

		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
		if (lp == null) {
			lp = new DragLayer.LayoutParams(0, 0);
			lp.customPosition = true;
			setLayoutParams(lp);
		}
		// centerAboutIcon();
	}

	private int getContentAreaHeight() {
		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		Rect workspacePadding = grid
				.getWorkspacePadding(grid.isLandscape ? CellLayout.LANDSCAPE
						: CellLayout.PORTRAIT);
		int maxContentAreaHeight = grid.availableHeightPx - 32
				* grid.edgeMarginPx - workspacePadding.top
				- workspacePadding.bottom - getPaddingTop()
				- getPaddingBottom() - mFolderNameHeight;
		return Math.min(maxContentAreaHeight, mContent.getDesiredHeight());
	}

	private int getContentAreawidth() {
		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
		Rect workspacePadding = grid
				.getWorkspacePadding(grid.isLandscape ? CellLayout.LANDSCAPE
						: CellLayout.PORTRAIT);
		int maxContentAreaHeight = grid.availableWidthPx - 1
				* grid.edgeMarginPx - workspacePadding.left
				- workspacePadding.right - getPaddingLeft() - getPaddingRight();
		return Math.min(maxContentAreaHeight, mContent.getDesiredHeight());

	}

	private int getFolderHeight() {
		int height = getPaddingTop() + getPaddingBottom()
				+ getContentAreaHeight() + mFolderNameHeight; // CellLayout高度+FolderName高度
		return height;
	}

	/**
	 * @param ev
	 * @param folderRect
	 * @return
	 */
	public boolean isOverLocationCellLayoutItem(MotionEvent ev, Rect folderRect) {
		for (int i = 0; i < mContent.getShortcutsAndWidgets().getChildCount(); i++) {
			View child = mContent.getShortcutsAndWidgets().getChildAt(i);
			ItemInfo info = (ItemInfo) child.getTag();

			Rect mHitRect = new Rect();
			mContent.cellToRect(info.cellX, info.cellY, info.spanX, info.spanY,
					mHitRect);
			mHitRect.left += folderRect.left;
			mHitRect.right += folderRect.left;
			mHitRect.top += folderRect.top;
			mHitRect.bottom += folderRect.top;

			if (mHitRect.contains((int) ev.getX(), (int) ev.getY())
					&& folderRect.contains((int) ev.getX(), (int) ev.getY())) {
				return true;
			}

		}
		return false;
	}

	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		int widthMode = MeasureSpec.getMode(widthMeasureSpec);
		int widthSize = MeasureSpec.getSize(widthMeasureSpec);
		int heightMode = MeasureSpec.getMode(heightMeasureSpec);
		int heightSize = MeasureSpec.getSize(heightMeasureSpec);
		int width = getPaddingLeft() + getPaddingRight()
				+ mContent.getDesiredWidth();
		int height = getFolderHeight();
		int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(widthSize,
				MeasureSpec.EXACTLY);
		int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(
				getContentAreaHeight(), MeasureSpec.EXACTLY);
		mContent.setFixedSize(widthSize, mContent.getDesiredHeight());
		mScrollView.measure(contentAreaWidthSpec, contentAreaHeightSpec);
		mFolderName.measure(contentAreaWidthSpec, MeasureSpec.makeMeasureSpec(
				mFolderNameHeight, MeasureSpec.EXACTLY));
		setMeasuredDimension(widthSize, height);
	}
	public void setVisibleView(VisibleAppsView v) {
		mVisibleAppsView = v;
	}

	/**
	 * 排序文件夹编辑
	 * 
	 * @param list
	 * @param componentNames
	 * @return
	 */
	private ArrayList<View> reorderAppsView(ArrayList<View> list,
			ArrayList<ComponentName> componentNames) {
		List<View> selectViews = new ArrayList<>();
		List<View> unSelectViews = new ArrayList<>();
		unSelectViews.addAll(list);
		Iterator it = unSelectViews.iterator();
		while (it.hasNext()) {
			View view = (View) it.next();
			ItemInfo info = (ItemInfo) view.getTag();
			for (ComponentName com : componentNames) {
				if (com.equals(info.getIntent().getComponent())) {
					it.remove();
					selectViews.add(view);

				}
			}
		}

		list.clear();
		list.addAll(selectViews);
		list.addAll(unSelectViews);

		return list;
	}

	private void arrangeChildren(ArrayList<View> list) {
		int[] vacant = new int[2];
		if (list == null) {
			list = getItemsInReadingOrder();
		}

		list = reorderAppsView(list, mComponentNames);
		mContent.removeAllViews();

		for (int i = 0; i < list.size(); i++) {
			View v = list.get(i);

			if (!(v instanceof BubbleTextView)) {
				CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v
						.getLayoutParams();
				mContent.addViewToCellLayout(v, -1, 0, lp, true);
				continue;
			}
			mContent.getVacantCell(vacant, 1, 1);
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v
					.getLayoutParams();
			lp.cellX = vacant[0];
			lp.cellY = vacant[1];
			ItemInfo info = (ItemInfo) v.getTag();
			if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
				info.cellX = vacant[0];
				info.cellY = vacant[1];
				/*
				 * LauncherModel.addOrMoveItemInDatabase(mLauncher, info,
				 * mInfo.id, 0, info.cellX, info.cellY);
				 */
			}
			boolean insert = false;
			mContent.addViewToCellLayout(v, insert ? 0 : -1, (int) info.id, lp,
					true);
		}
		mItemsInvalidated = true;
	}

	public int getItemCount() {
		return mContent.getShortcutsAndWidgets().getChildCount();
	}

	public View getItemAt(int index) {
		return mContent.getShortcutsAndWidgets().getChildAt(index);
	}

	private void onCloseComplete() {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "onCloseComplete: parent = " + getParent());
		}

		DragLayer parent = (DragLayer) getParent();
		if (parent != null) {
			parent.removeView(this);
		}
		// mDragController.removeDropTarget((DropTarget) this);
		clearFocus();
		/*
		 * mFolderIcon.requestFocus();
		 * 
		 * if (mRearrangeOnClose) { setupContentForNumItems(getItemCount());
		 * mRearrangeOnClose = false; } if (getItemCount() <= 1) { if
		 * (!mDragInProgress && !mSuppressFolderDeletion) {
		 * replaceFolderWithFinalItem(); } else if (mDragInProgress) {
		 * mDeleteFolderOnDropCompleted = true; } } mSuppressFolderDeletion =
		 * false;
		 */
	}

	private void replaceFolderWithFinalItem() {
		// Add the last remaining child to the workspace in place of the folder
		Runnable onCompleteRunnable = new Runnable() {
			@Override
			public void run() {
				CellLayout cellLayout = mLauncher.getCellLayout(
						mInfo.container, mInfo.screenId);

				View child = null;
				// Move the item from the folder to the workspace, in the
				// position of the folder
				if (getItemCount() == 1) {
					ShortcutInfo finalItem = mInfo.contents.get(0);
					child = mLauncher.createShortcut(R.layout.application,
							cellLayout, finalItem);
					LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem,
							mInfo.container, mInfo.screenId, mInfo.cellX,
							mInfo.cellY);
				}
				// We add the child after removing the folder to prevent both
				// from existing at
				// the same time in the CellLayout. We need to add the new item
				// with addInScreenFromBind()
				// to ensure that hotseat items are placed correctly.
				if (child != null) {
					mLauncher.getWorkspace().addInScreenFromBind(child,
							mInfo.container, mInfo.screenId, mInfo.cellX,
							mInfo.cellY, mInfo.spanX, mInfo.spanY);
				}
			}
		};
		mDestroyed = true;
	}

	boolean isDestroyed() {
		return mDestroyed;
	}

	// This method keeps track of the last item in the folder for the purposes
	// of keyboard focus
	private void updateTextViewFocus() {
		View lastChild = getItemAt(getItemCount() - 1);
		getItemAt(getItemCount() - 1);
		if (lastChild != null) {
			mFolderName.setNextFocusDownId(lastChild.getId());
			mFolderName.setNextFocusRightId(lastChild.getId());
			mFolderName.setNextFocusLeftId(lastChild.getId());
			mFolderName.setNextFocusUpId(lastChild.getId());
		}
	}

	public void onDrop(DragObject d) {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "onDrop: DragObject = " + d);
		}

		ShortcutInfo item;
		if (d.dragInfo instanceof AppInfo) {
			// Came from all apps -- make a copy
			item = ((AppInfo) d.dragInfo).makeShortcut();
			item.spanX = 1;
			item.spanY = 1;
		} else {
			item = (ShortcutInfo) d.dragInfo;
		}
		// Dragged from self onto self, currently this is the only path
		// possible, however
		// we keep this as a distinct code path.
		if (item == mCurrentDragInfo) {
			ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView
					.getLayoutParams();
			si.cellX = lp.cellX = mEmptyCell[0];
			si.cellX = lp.cellY = mEmptyCell[1];
			mContent.addViewToCellLayout(mCurrentDragView, -1, (int) item.id,
					lp, true);
			if (d.dragView.hasDrawn()) {
				mLauncher.getDragLayer().animateViewIntoPosition(d.dragView,
						mCurrentDragView, 0, false, null);
			} else {
				d.deferDragViewCleanupPostAnimation = false;
				mCurrentDragView.setVisibility(VISIBLE);
			}
			mItemsInvalidated = true;
			setupContentDimensions(getItemCount());
			mSuppressOnAdd = true;
		}
		mInfo.add(item);
	}

	// This is used so the item doesn't immediately appear in the folder when
	// added. In one case
	// we need to create the illusion that the item isn't added back to the
	// folder yet, to
	// to correspond to the animation of the icon back into the folder. This is
	public void hideItem(ShortcutInfo info) {
		View v = getViewForInfo(info);
		if (v != null)
			v.setVisibility(INVISIBLE);
	}

	public void showItem(ShortcutInfo info) {
		View v = getViewForInfo(info);
		if (v != null)
			v.setVisibility(VISIBLE);
	}

	public void onAdd(ShortcutInfo item) {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "onAdd item = " + item);
		}

		mItemsInvalidated = true;
		// If the item was dropped onto this open folder, we have done the work
		// associated
		// with adding the item to the folder, as indicated by mSuppressOnAdd
		// being set
		if (mSuppressOnAdd)
			return;
		if (!findAndSetEmptyCells(item)) {
			// The current layout is full, can we expand it?
			setupContentForNumItems(getItemCount() + 1);
			findAndSetEmptyCells(item);
		}
		createAndAddShortcut(item);
		LauncherModel.addOrMoveItemInDatabase(mLauncher, item, mInfo.id, 0,
				item.cellX, item.cellY);
	}

	public void onRemove(ShortcutInfo item, State state) {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "onRemove item = " + item);
		}

		mItemsInvalidated = true;
		// If this item is being dragged from this open folder, we have already
		// handled
		// the work associated with removing the item, so we don't have to do
		// anything here.
		if (item == mCurrentDragInfo)
			return;
		View v = getViewForInfo(item);
		mContent.removeView(v);
		if (mState == STATE_ANIMATING) {
			mRearrangeOnClose = true;
		} else {
			setupContentForNumItems(getItemCount());
		}
		if (getItemCount() <= 1 && state == State.NORMAL) {
			replaceFolderWithFinalItem();
		}
	}

	private View getViewForInfo(ShortcutInfo item) {
		for (int j = 0; j < mContent.getCountY(); j++) {
			for (int i = 0; i < mContent.getCountX(); i++) {
				View v = mContent.getChildAt(i, j);
				if (v != null) {
					if (v.getTag() == item) {
						return v;
					}
				}
			}
		}
		return null;
	}

	public void onItemsChanged() {
		updateTextViewFocus();
	}

	public void onTitleChanged(CharSequence title) {
	}

	public ArrayList<View> getItemsInReadingOrder() {
		if (mItemsInvalidated) {
			mItemsInReadingOrder.clear();
			for (int j = 0; j < mContent.getCountY(); j++) {
				for (int i = 0; i < mContent.getCountX(); i++) {
					View v = mContent.getChildAt(i, j);
					if(v == null) {
						LogUtils.i("zhouerlong", "info:----------nul null");
					}
					if (v != null) {
						ItemInfo info = (ItemInfo) v.getTag();
						LogUtils.i("zhouerlong", "info:"+info.title);
						mItemsInReadingOrder.add(v);
					}
				}
			}
			// mItemsInvalidated = false;
		}
		return mItemsInReadingOrder;
	}

	public void getLocationInDragLayer(int[] loc) {
		mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
	}

	public CellLayout getLayout() {
		return mContent;
	}
	public void onFocusChange(View v, boolean hasFocus) {
		if (v == mFolderName && hasFocus) {
			startEditingFolderName();
		}
	}

	@Override
	public void getHitRectRelativeToDragLayer(Rect outRect) {
		getHitRect(outRect);
	}

	@Override
	public void onFristEnter(DragObject dragObject) {
		// TODO Auto-generated method stub

	}

	@Override
	public void onStartMuitipleDrag(View child, DragObject dragobject,
			Runnable exitSpringLoadedRunnable, View dragChild) { // TODO
																	// Auto-generated
																	// method
																	// stub

	}
}
