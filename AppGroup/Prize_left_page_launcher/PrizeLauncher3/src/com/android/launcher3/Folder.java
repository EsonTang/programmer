/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.launcher3;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;

import android.animation.Animator;
import android.animation.Animator.AnimatorListener;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.app.Activity;
import android.app.WallpaperManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.Message;
import android.os.SystemClock;
import android.support.v4.view.ViewPager;
import android.support.v4.widget.AutoScrollHelper;
import android.text.Editable;
import android.text.InputFilter;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ActionMode;
import android.view.Display;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.view.animation.BaseInterpolator;
import android.view.animation.Interpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

import com.android.download.DownLoadService;
import com.android.download.DownLoadTaskInfo;
import com.android.gallery3d.util.LogUtils;
import com.android.launcher3.FolderInfo.FolderListener;
import com.android.launcher3.FolderInfo.State;
import com.android.launcher3.anim.LauncherFolderAnimations;
import com.android.launcher3.anim.TransitionAnims.TransitionListener;
import com.android.launcher3.lq.DefaultConfig;
import com.android.launcher3.playview.PrizePlayView;
import com.android.launcher3.tsearch.MyViewPagerAdapter;
import com.android.launcher3.view.FolderTextViewReLativelayout;
import com.android.launcher3.view.MyScrollView;
import com.android.launcher3.view.PrizeSwitchView;
import com.android.launcher3.view.MyScrollView.OnTouchStateListener;
import com.android.launcher3.view.PrizeBubbleTextView;
import com.android.launcher3.view.FolderTextViewReLativelayout.OnPageSelected;
import com.android.launcher3.view.LauncherBackgroudView;
import com.baidu.android.a.a.e;
import com.mediatek.launcher3.ext.LauncherLog;
//import com.android.launcher3.LauncherViewPropertyAnimator.Properties;
import com.nostra13.universalimageloader.core.ImageLoader;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource, View.OnClickListener,
        View.OnLongClickListener, DropTarget, FolderListener, TextView.OnEditorActionListener,OnPageSelected,
        View.OnFocusChangeListener, TextWatcher {
    private static final String TAG = "Launcher.Folder";

    protected DragController mDragController;
    
    protected Launcher mLauncher;
    public Launcher getmLauncher() {
		return mLauncher;
	}
	public void setmLauncher(Launcher mLauncher) {
		this.mLauncher = mLauncher;
	}

	protected FolderInfo mInfo;

    static final int STATE_NONE = -1;
    public static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;
//add by zhouerlong
    private final float SCANLE_ANIM_MI=0.18f;
    private final float SCANLE_LAUNCHERBC_MAX=5.2f;
    private final float WALL_SCALE=1.1f;
    private final float SCANLE_ANIM_MAX=0.85f;
//add by zhouerlong

    private int mExpandDuration;
    protected CellLayout mContent;
    private Interpolator mZoomInInterpolator =new DecelerateInterpolator() ;
    private final BaseInterpolator mZoomInInterpolator1 = new DecelerateInterpolator();
    
    private Handler mHandler = new Handler();
//add by zhouerlong
    protected ScrollView mScrollView;
    
    public ScrollView getScrollView() {
		return mScrollView;
	}
    
    

	private ObjectAnimator mAnim = null;
	private ObjectAnimator mAlpha = null;
	/***
	 * 开始动画
	 */
	public void start() {
		if (null == mAnim) {
			mAnim = ObjectAnimator  
					.ofFloat(mScrollView, "translationY", 100.0F);
			mAnim.setDuration(400);
		}
		mAnim.start();
		

		if (null == mAlpha) {
			mAlpha = ObjectAnimator  
					.ofFloat(mScrollView, "alpha", 0.05f);
			mAlpha.setDuration(400);
		}
		mAlpha.start();
	
	}
	/***
	 * 结束动画
	 */
	public void end() {
		mAnim.reverse();
		mAlpha.reverse();
	}
	public void setScrollView(ScrollView mScrollView) {
		this.mScrollView = mScrollView;
	}

	private ViewPager mViewPager;
    public ViewPager getViewPager() {
		return mViewPager;
	}
	public void setViewPager(ViewPager mViewPager) {
		this.mViewPager = mViewPager;
	}
	
	

	private final LayoutInflater mInflater;
	private final IconCache mIconCache;
	private int mState = STATE_NONE;
	private static final int REORDER_ANIMATION_DURATION = 230;
	private static final int REORDER_DELAY = 100;
	private boolean mRearrangeOnClose = false;
	private FolderIcon mFolderIcon;
	public FolderIcon getmFolderIcon() {
		return mFolderIcon;
	}
	public void setmFolderIcon(FolderIcon mFolderIcon) {
		this.mFolderIcon = mFolderIcon;
	}

	private int mMaxCountX;
	private View mOtherView;
	private View mOtherView1;
	// add by zhouerlong
	private int mMaxCountY;
	private int mMaxNumItems;
	private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
	private Drawable mIconDrawable;
	boolean mItemsInvalidated = false;
	private ShortcutInfo mCurrentDragInfo;
	private View mCurrentDragView;
	boolean mSuppressOnAdd = false;
	private int[] mTargetCell = new int[2];
	private int[] mPreviousTargetCell = new int[2];
	private int[] mEmptyCell = new int[2];
	private Alarm mReorderAlarm = new Alarm();
	private Alarm mOnExitAlarm = new Alarm();
	private int mFolderNameHeight;
	private Rect mTempRect = new Rect();
	private boolean mDragInProgress = false;
	private boolean mDeleteFolderOnDropCompleted = false;
	private boolean mSuppressFolderDeletion = false;
	private boolean mItemAddedBackToSelfViaIcon = false;
	FolderEditText mFolderName;
	private float mFolderIconPivotX;
	private float mFolderIconPivotY;
	String oldTitle;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private static String sDefaultFolderName;
    private static String sHintText;

    private int DRAG_MODE_NONE = 0;
    private int DRAG_MODE_REORDER = 1;
    private int mDragMode = DRAG_MODE_NONE;

    private boolean mDestroyed;

    private AutoScrollHelper mAutoScrollHelper;

    private Runnable mDeferredAction;
    private boolean mDeferDropAfterUninstall;
    private boolean mUninstallSuccessful;
    private LauncherBackgroudView mWallpaperView;//M by xxf
    private FitSystemWindow  mLauncherBackground;//M by xxf

	private HashMap<Object,Folder> mFolders;
    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);

        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        setAlwaysDrawnWithCacheEnabled(false);
        mInflater = LayoutInflater.from(context);
        mIconCache = app.getIconCache();

        Resources res = getResources();
//add by zhouerlong
        mMaxCountX = 3;//(int) grid.numColumns;//M by zhouerlong
        mMaxCountY = 40;//(int) grid.numRows;//M by zhouerlong
//add by zhouerlong
        mMaxNumItems = mMaxCountX * mMaxCountY;

        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        mExpandDuration = res.getInteger(R.integer.config_folderAnimDuration);

        mZoomInInterpolator =AnimationUtils.loadInterpolator(context,
                com.android.internal.R.interpolator.decelerate_cubic);

        if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }
        if (sHintText == null) {
            sHintText = res.getString(R.string.folder_hint_text);
        }
        mLauncher = (Launcher) context;
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
    }
    
	HashMap<Object, View> getScrollViews(HashMap<Object, Folder> folders,
			Object tag,List<View> list) {
		HashMap<Object, View> scrolls = new HashMap<>();
		this.removeView(mScrollView);
		mScrollView.setTag(this.getInfo());
		list.add(mScrollView);
		scrolls.put(this.getInfo(), mScrollView);
		Iterator<Entry<Object, Folder>> it = folders.entrySet().iterator();
		int index=0;
		while (it.hasNext()) {
			Folder f = it.next().getValue();

			f.requestLayout();
			CellLayout content = f.getContent();
			int contentHeight = content.getDesiredHeight();
			if (contentHeight == 0) {
				contentHeight = content.getDesiredHeightForge();
			}
			content.setFixedSize(mContent.getDesiredWidth(), contentHeight);
			View v = f.getScrollView();
			if (f.getInfo() != tag&&
					f.getInfo().getContents().size()>0) {
				f.removeView(v);
				v.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,
						LayoutParams.MATCH_PARENT));
				scrolls.put(f.getInfo(), v);
				index++;
				v.setTag(f.getInfo());
				list.add(v);
				
			}

		}

		return scrolls;
	}
	
	
	public void scrollToPos() {

		int scrollY = mScrollView.getScrollY();
		int lineheight = mContent.getShortcutsAndWidgets()
				.getChildAt(0).getMeasuredHeight();
		
		int targetpos =  Math.round((scrollY % lineheight/(float)lineheight));
			int targetoffset = targetpos==0?(-scrollY % lineheight):(lineheight-scrollY % lineheight);
			mScrollView
			.smoothScrollBy(0, targetoffset);
	}

	public interface  OnScrollListener {
		public  void OnScrollListener();
	}
	
	public OnScrollListener mOnTouchListener=null;
	
	public void setOnScrollListener(OnScrollListener l) {
		mOnTouchListener = l;
	}
	public void scrollToEnd() {

		try {
		int fromscrollY = mScrollView.getScrollY();
		int lineheight = mContent.getShortcutsAndWidgets()
				.getChildAt(0).getMeasuredHeight();
		int[] cell = new int[2];
			mContent.getLastNewPosition(cell);
			int y=cell[1]+1;
			int toScrollY=y*lineheight;
				int targetoffset =toScrollY-fromscrollY;
				mScrollView
				.smoothScrollBy(0, targetoffset);
		} catch (Exception e) {
			// TODO: handle exception
		}
	}
    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mScrollView = (ScrollView) findViewById(R.id.scroll_view);
        mContent = (CellLayout) findViewById(R.id.folder_content);
        mWallpaperView = (LauncherBackgroudView) mLauncher.findViewById(R.id.wallpaper_bg);
        mLauncherBackground = (FitSystemWindow) mLauncher.findViewById(R.id.workspaceAndOther);
        mViewPager = (ViewPager) findViewById(R.id.folders_view_pager);
        mScrollView.setOnScrollChangeListener(new OnScrollChangeListener() {
			
			@Override
			public void onScrollChange(View arg0, int arg1, int arg2, int arg3, int arg4) {
				// TODO Auto-generated method stub

				if(mOnTouchListener!=null)
					mOnTouchListener.OnScrollListener();
			}
		});
        mScrollView.setOnScrollChangeListener(new OnScrollChangeListener() {
			
			@Override
			public void onScrollChange(View arg0, int arg1, int arg2, int arg3, int arg4) {
				// TODO Auto-generated method stub
				
			}
		});
		if(mScrollView instanceof MyScrollView) {
			((MyScrollView) mScrollView)
					.setOnTouchStateListener(new OnTouchStateListener() {

						@Override
						public void onTouchStateListener() {
							scrollToPos();
							}
						});
		}
        
        
       
//add by zhouerlong
        
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();

        mContent.setCellDimensions(grid.folderCellWidthPx, grid.folderCellHeightPx);
        mContent.setGridSize(0, 0);
        mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
        mContent.setInvertIfRtl(true);
        mFolderName = (FolderEditText) findViewById(R.id.folder_name);
        //mFolderName.setFilters(new InputFilter[]{new InputFilter.LengthFilter(6)});
        mFolderName.setFolder(this);
        mFolderName.setTextSize(24);
        mFolderName.setOnFocusChangeListener(this);
        mFolderName.addTextChangedListener(this);

        // We find out how tall the text view wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        int measureSpec = MeasureSpec.UNSPECIFIED;
        mFolderName.measure(measureSpec, measureSpec);
        mFolderNameHeight = mFolderName.getMeasuredHeight();

        // We disable action mode for now since it messes up the view on phones
        mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
        mFolderName.setOnEditorActionListener(this);
        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);
    }

    public CellLayout getContent() {
		return mContent;
	}
	public void setContent(CellLayout mContent) {
		this.mContent = mContent;
	}

	private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            return false;
        }

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        public void onDestroyActionMode(ActionMode mode) {
        }

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }
    };

	private TextView mAddMoreTextView;//M by zhouerlong

	private FolderTextViewReLativelayout mMoreView;
	public View getMoreView() {
		return mMoreView;
	}
    public void onClick(View v) {
        Object tag = v.getTag();
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onClick: v = " + v + ", tag = " + tag);
        }

        if (tag instanceof ShortcutInfo) {
            mLauncher.onClick(v);
        }
    }

    public boolean onLongClick(View v) {
        // Return if global dragging is not enabled
        if (!mLauncher.isDraggingEnabled()) return true;

        Object tag = v.getTag();
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onLongClick: v = " + v + ", tag = " + tag);
        }

        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }

            mLauncher.dismissFolderCling(null);

            mLauncher.getWorkspace().onDragStartedWithItem(v);
            try {
                mLauncher.getWorkspace().beginDragShared(v, this);
			} catch (Exception e) {
				// TODO: handle exception
			}
            mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

            mCurrentDragInfo = item;
            mEmptyCell[0] = item.cellX;
            mEmptyCell[1] = item.cellY;
            mCurrentDragView = v;
            mContent.removeView(mCurrentDragView);
            mInfo.remove(mCurrentDragInfo,State.NORMAL);//M by zhouerlong
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
        }
        return true;
    }

	public boolean isEditingName() {
		return mIsEditingName;
	}

	public void startEditingFolderName() {
		mInputMethodManager.showSoftInput(mFolderName, 0);
		oldTitle = mFolderName.getText().toString();
		mFolderName.setHint("");
		mFolderName.setSelection(mFolderName.getText().length());
		mIsEditingName = true;
	}

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        try {
            doneEditingFolderName(true);
		} catch (Exception e) {
			// TODO: handle exception
		}
    }

	public void doneEditingFolderName(boolean commit) {
		// / M: [ALPS01250799] Get correct folder hint string before setting
		// hint.
		sHintText = getResources().getString(R.string.folder_hint_text);
		mFolderName.setHint(sHintText);
		if(pagers) {
		mMoreView.setVisibility(View.VISIBLE);
		mFolderName.setVisibility(View.INVISIBLE);
		}
		

    	PrizeSwitchView psw = (PrizeSwitchView) mFolderIcon.getSwitchView();
    	psw.end();
    	end();
		// Convert to a string here to ensure that no other state associated
		// with the text field
		// gets saved.
		String newTitle = mFolderName.getText().toString();
		 mInfo.setTitle(newTitle);
		 if(!(newTitle.length() > 0  && !newTitle.trim().isEmpty() && newTitle.equals(oldTitle))) 
		 {
			 mInfo.setTitleId(-1);
		 }
		if(pagers) {
		TextView current = (TextView) mMoreView.getChildAt(mCurrentPosition);
		FolderInfo info = (FolderInfo) current.getTag();
		if (newTitle.length() > 0  && !newTitle.trim().isEmpty() && !newTitle.equals(oldTitle)) {
			current.setText(newTitle);
			info.setTitle(newTitle);
			info.setTitleId(0);
		} else {
			current.setText(oldTitle);
			info.setTitle(oldTitle);
			info.setTitleId(-1);
		}
		}
		
		LauncherModel.updateItemInDatabase(mLauncher, mFolderIcon.getFolderInfo());

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }
        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
        requestFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            dismissEditingName();
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }

    public Drawable getDragDrawable() {
        return mIconDrawable;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    FolderInfo getInfo() {
        return mInfo;
    }

    private class GridComparator implements Comparator<ShortcutInfo> {
        int mNumCols;
        public GridComparator(int numCols) {
            mNumCols = numCols;
        }

        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            int lhIndex = lhs.cellY * mNumCols + lhs.cellX;
            int rhIndex = rhs.cellY * mNumCols + rhs.cellX;
            return (lhIndex - rhIndex);
        }
    }

    private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
        int maxX = 0;
        int count = items.size();
        for (int i = 0; i < count; i++) {
            ShortcutInfo item = items.get(i);
            if (item.cellX > maxX) {
                maxX = item.cellX;
            }
        }

        GridComparator gridComparator = new GridComparator(maxX + 1);
        Collections.sort(items, gridComparator);
        final int countX = mContent.getCountX();
        for (int i = 0; i < count; i++) {
            int x = i % countX;
            int y = i / countX;
            ShortcutInfo item = items.get(i);
            item.cellX = x;
            item.cellY = y;
        }
    }

    void bind(FolderInfo info) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;
        ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
        setupContentForNumItems(children.size());
        placeInReadingOrder(children);
        int count = 0;
        for (int i = 0; i < children.size(); i++) {
            ShortcutInfo child = (ShortcutInfo) children.get(i);
            if (!createAndAddShortcut(child)) {
                overflow.add(child);
            } else {
                count++;
            }
        }

        // We rearrange the items in case there are any empty gaps
        setupContentForNumItems(count);

        // If our folder has too many items we prune them from the list. This is an issue 
        // when upgrading from the old Folders implementation which could contain an unlimited
        // number of items.
        for (ShortcutInfo item: overflow) {
            mInfo.remove(item,State.NORMAL);//M by zhouerlong
            LauncherModel.deleteItemFromDatabase(mLauncher, item);
        }

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        if (!sDefaultFolderName.contentEquals(mInfo.title) 
        		&& !TextUtils.isEmpty(mInfo.title)) {
            mFolderName.setText(mInfo.title);

            if (mInfo.title_id != -1&&mInfo.title_id != 0) {
            	try {
            		if(!mContext.getString(mInfo.title_id).equals("false"))
                	mFolderName.setText(mInfo.title_id);
				} catch (Exception e) {
					e.printStackTrace();
				}
            }
        } else {
            mFolderName.setText(sDefaultFolderName);//M by xiaxuefeng
        }
        updateItemLocationsInDatabase();
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param context The application's context.
     *
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) {
        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        setScaleX(0.8f);
        setScaleY(0.8f);
        /*setAlpha(0f);*/
//add by zhouerlong
        
        mState = STATE_SMALL;
    }
//add by zhouerlong
    private void positionBg() {
    	mScrollView.setBackgroundResource(R.drawable.folder_cell_bg);//A by zhouerlong
    }
  class  FolderAnimatorUpLIstner  implements AnimatorUpdateListener {

	@Override
	public void onAnimationUpdate(ValueAnimator animation) {
		float v =  (Float) animation.getAnimatedValue();
		mScrollView.getBackground().setAlpha((int) (v*255));//A by zhouerlong
		
	}
    	
    }
	
	public void closeCellLayoutBgAnimation() {
		
//M by zhouerlong
        ValueAnimator va = ValueAnimator.ofFloat(1f,0f);
        va.setDuration(mExpandDuration*10);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        va.start();
        va.addUpdateListener(new FolderAnimatorUpLIstner());
        va.addListener(new AnimatorListener() {
			
			public void onAnimationStart(Animator arg0) {
				// TODO Auto-generated method stub
				
			}
			
			public void onAnimationRepeat(Animator arg0) {
				// TODO Auto-generated method stub
				
			}
			
			public void onAnimationEnd(Animator arg0) {
				mScrollView.setBackgroundColor(Color.TRANSPARENT);
				
			}
			
			public void onAnimationCancel(Animator arg0) {
				// TODO Auto-generated method stub
				
			}
		});
      
	}
  	
  	public void openCellLayoutBgAnimation() {
  		positionBg();
        ValueAnimator va = ValueAnimator.ofFloat(0f,1f);//M by zhouerlong
        va.setDuration(mExpandDuration*10);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        va.start();
        va.addUpdateListener(new FolderAnimatorUpLIstner());
        
  	}
  	//A by zhouerlong
	public void addLastAddFolderIconButton(int cellX, int cellY) {
		LayoutInflater inflater = LayoutInflater.from(mContext);
		if (mContent.getChildrenLayout().indexOfChild(mAddMoreTextView) != -1) {
			return;
		}
		if (mAddMoreTextView == null) {
			mAddMoreTextView = (TextView) inflater.inflate(
					R.layout.all_apps_button, mContent, false);
			Drawable d = mContext.getResources().getDrawable(
					R.drawable.a_target_selector);
			Utilities.resizeIconDrawable(d);
			mAddMoreTextView.setCompoundDrawables(null, d, null, null);
			mAddMoreTextView
					.setText(com.android.internal.R.string.more_item_label);
		}
		mAddMoreTextView.setOnClickListener(new OnClickListener() {

			private HideAppsView mCheckFolderView;

			@Override
			public void onClick(View v) {
				/*mCheckFolderView = mLauncher.getFolderCheckBoxView();
				mCheckFolderView.setFolderIcon(mFolderIcon);
				mCheckFolderView.bind(mInfo);

				
				 * DragLayer parents = (DragLayer)
				 * mLauncher.findViewById(R.id.drag_layer); if
				 * (checkView.getParent() == null) { parents.addView(checkView);
				 * }
				 
				mLauncher.addFolderCheckBoxView(mCheckFolderView);
				mCheckFolderView.setupContentForNumItems(mCheckFolderView
						.getContents().size());
				mCheckFolderView.animateOpen(mMoreView);*/

			}
		});
		if(getItemCount()%mMaxCountX==0) {
			 setupContentDimensions(getItemCount()+1);
		}
		CellLayout.LayoutParams lp = new CellLayout.LayoutParams(cellX, cellY,
				1, 1);
		lp.canReorder = false;
		mContent.addViewToCellLayout(mAddMoreTextView, -1, 0, lp, true);
		
        setupContentDimensions(getItemCount());
	}

	public void addMoreIcon() {


		LayoutInflater inflater = LayoutInflater.from(mContext);

		 mMoreView =(FolderTextViewReLativelayout) inflater.inflate(R.layout.more_icon, null);
		 mMoreView.setOnPageSelected(this);
		 mMoreView.setVisibility(View.VISIBLE);
			mFolderName.setVisibility(View.INVISIBLE);
		 mMoreView.setOnClickListener(new View.OnClickListener(
				 ) {
			
			@Override
			public void onClick(View v) {
				TextView t=(TextView)mMoreView.getChildAt(mCurrentPosition);
				mFolderName.setText(t.getText().toString());
				mFolderName.setVisibility(View.VISIBLE);
				mMoreView.setVisibility(View.INVISIBLE);
		        mFolderName.setClickable(true);
		        mFolderName.requestFocus();
		        startEditingFolderName();
			}
		});
		if (parent.indexOfChild(mMoreView) !=-1) {
			return; 
		}
		DragLayer.LayoutParams lp = new DragLayer.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
		lp.customPosition = true;
        lp.width = getMeasuredWidth();
        lp.height = mFolderNameHeight;
        View    hot= mLauncher.getHotseat();
        Rect r = new Rect();
        float scale =parent.getDescendantRectRelativeToSelf(mFolderName,r);
        Display display = ((Activity) this.getContext()).getWindowManager().getDefaultDisplay();
        int x =(display.getWidth()-lp.width)/2;
        int y = r.top;
        lp.x = (int) to[0];
        lp.y = (int) ((int) r.top);
        mMoreView.bringToFront();
          parent.addView(mMoreView,lp);
        ;
	}
    int[] from = new int[2];
    int[] to = new int[2];

	private HashMap<Object, View> mScrolls;

	public static boolean pagers=false;

    public static List<View> covertMapToArrayList(HashMap<Object ,View>map){
    	List<View> list = new ArrayList();
    	  Iterator it = map.keySet().iterator();
    	  while (it.hasNext()) {
			Object  key = it.next();
			list.add(map.get(key));
			
		}
    	  return list;
    	 }
	/**
	 * 文件夹打开动画
	 */
	public void animateOpen(final boolean first) {
		if (!(getParent() instanceof DragLayer))
			return;
		final WallpaperManager wm = WallpaperManager.getInstance(mLauncher);
//		mWallpaperView.setLauncherBg(wm.getFastDrawable());
//    	mWallpaperView.invalidate();
		mLauncher.bindDownloadService();
		centerAboutIcon(from, to);
		this.setAlpha(1f);
		
		LauncherFolderAnimations mFolderAnimator = new LauncherFolderAnimations(mZoomInInterpolator);
		int fromX = 0;
		int fromY = 0;
		int toX = to[0] - from[0];
		int toY = to[1] - from[1];

      /*  int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(mContent.getDesiredWidth(),
                MeasureSpec.EXACTLY);
        int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(getContentAreaHeight(),
                MeasureSpec.EXACTLY);
        mScrollView.measure(contentAreaWidthSpec, contentAreaHeightSpec);
        this.requestLayout();*/
//		mScrollView.setBackground(mLauncher.getDrawable(R.drawable.folder_cell_bg1));
		mScrollView.scrollTo(fromX, fromY);
		
		mFolderAnimator.play(this,
				new float[] { SCANLE_ANIM_MI, SCANLE_ANIM_MI }, new float[] {
						1f, 1f }, from, to);
//		mWallpaperView.setAlpha(1.0f);
//		mWallpaperView.setVisibility(View.VISIBLE);
		if(!mLauncher.getworkspace().isInSpringLoadMoed())
		{
			mWallpaperView.setupOrgWallpaper();
			mFolderAnimator.play(mWallpaperView,1f);
		}
		mFolderAnimator.play(mLauncherBackground, 0f);
		mFolderAnimator.play(mLauncher.getFolderIconImageView(), 0f);
		mFolderAnimator.play(mLauncher.getFolderIconImageViewbg(), 0f);
		mFolderAnimator.setListener(new TransitionListener() {

			public void onTransitionStart(Animator animator, Animation animation) {
				mScrollView.setVerticalScrollBarEnabled(false);
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, String
								.format(getContext().getString(
										R.string.folder_opened),
										mContent.getCountX(),
										mContent.getCountY()));
				mState = STATE_ANIMATING;
				mLauncherBackground.setLayerType(LAYER_TYPE_HARDWARE, null);
				mFolderName.setAlpha(0f);
				if(!mLauncher.getworkspace().isInSpringLoadMoed())
				mWallpaperView.setVisibility(View.VISIBLE);

			}

			AnimTool tool = null;
			public void onTransitionEnd(Animator animator, Animation animation) {
				mScrollView.setVerticalScrollBarEnabled(true);
				mState = STATE_OPEN;
				setLayerType(LAYER_TYPE_NONE, null);
				if(mFolderIcon.getRecommdView() instanceof PrizeRecommdView) {
		        	PrizeRecommdView p = (PrizeRecommdView) mFolderIcon.getRecommdView();
		        	p.open();
				}else {
					
					if(mFolderIcon.getFolderInfo().recommd_dis==1) {
						RecommdLinearLayout ps =  (RecommdLinearLayout) mFolderIcon.getRecommdView();
			        	ps.open();
					}
				}
				
				if(first) {
	            	/*PrizeSwitchView psw = (PrizeSwitchView) mFolderIcon.getSwitchView();
	            	start();
	            	psw.open();*/
					mFolderName.requestFocus();

//					doneEditingFolderName(true);
				}
				mLauncherBackground.setLayerType(LAYER_TYPE_NONE, null);
				updateContentUnreadNum();
				mLauncher.getworkspace().isCreate=false;
				
				if(tool ==null) {
					 tool = new AnimTool();
				}
				if(mLauncher.getworkspace().isInSpringLoadMoed())
				tool.starts(mContent);
				setFocusOnFirstChild();
				if (pagers) {
					mViewPager.setVisibility(View.VISIBLE);
					mScrollView.setBackground(null);
					mViewPager.setBackground(mLauncher.getDrawable(R.drawable.folder_cell_bg));
					if (mFolders != null && !mFolders.isEmpty()) {
						mFolders.clear();
					}
					mFolders = mLauncher.getworkspace().getFolders();
					if (mScrolls != null && !mScrolls.isEmpty()) {
						mScrolls.clear();
					}
					List<View> list = new ArrayList<>();
					addMoreIcon();

					mScrolls = getScrollViews(mFolders, getInfo(), list);
					LinearLayout.LayoutParams lp =(LinearLayout.LayoutParams) mViewPager.getLayoutParams();
					lp.setMargins(-2, 0, 0, 0);
					mViewPager
					.setAdapter(new MyViewPagerAdapter(mContext, list));
			 		 mMoreView.setViewPager(mViewPager);
					for(int i=0;i<list.size();i++) {
						mMoreView.addTextView(i, list.get(i).getTag(),
								getMeasuredWidth(),
								mMoreView.getLayoutParams().height, 24,to[0]);
					}
				}

				visibleMoreIcon(true, null);
			}
		});


		int d=Utilities.getOpenFolderDuration();
		mFolderAnimator.setDuration(d);
		mFolderAnimator.setInterpolator(mZoomInInterpolator);
		mFolderAnimator.start();
	}
	

	
	private void visibleMoreIcon(boolean visible,AnimatorListenerAdapter adapter) {
		float from=visible?0f:1f;
		float to = 1f-from;
        ValueAnimator scale = ObjectAnimator.ofFloat(from,to);
        scale.addUpdateListener(new AnimatorUpdateListener() {
			
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float alpha = (float) animation.getAnimatedValue();
				mFolderName.setAlpha(alpha);
//				mMoreView.setAlpha(alpha);
			}
		});
        if (adapter != null) {
        	scale.addListener(adapter);
        }
        if (visible)
//        scale.setStartDelay(REORDER_DELAY);
        scale.setDuration(500);
        scale.setInterpolator(mZoomInInterpolator);
        scale.start();
	}
    
    private void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    private void setFocusOnFirstChild() {
        View firstChild = mContent.getChildAt(0, 0);
        if (firstChild != null) {
            firstChild.requestFocus();
        }
    }
    //截取View的Bitmap 位图
	public static Bitmap convertViewToBitmap(View view, int bitmapWidth,
			int bitmapHeight) {
		Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
				Bitmap.Config.ARGB_8888);
		view.draw(new Canvas(bitmap));

		return bitmap;
	}
	//玻璃效果关闭操作
	public void closeBlueOption() {

		PropertyValuesHolder alphaother = PropertyValuesHolder.ofFloat("alpha",
				0);
		final ObjectAnimator oo = LauncherAnimUtils.ofPropertyValuesHolder(
				mOtherView, alphaother);
		final ObjectAnimator oE = LauncherAnimUtils.ofPropertyValuesHolder(
				mOtherView1, alphaother);

		oo.setDuration(mExpandDuration*3);
		//
		setLayerType(LAYER_TYPE_HARDWARE, null);
		oo.start();

		oE.setDuration(mExpandDuration*3);

		setLayerType(LAYER_TYPE_HARDWARE, null);
		oE.start();
		oo.addListener(new AnimatorListener() {

			@Override
			public void onAnimationStart(Animator arg0) {
				// TODO Auto-generated method stub

			}

			@Override
			public void onAnimationRepeat(Animator arg0) {
				// TODO Auto-generated method stub

			}

			@Override
			public void onAnimationEnd(Animator arg0) {
                mInfo.opened = false;

                requestLayout();
                mFolderIcon.requestLayout();
				if (mOtherView != null && mOtherView1 != null) {
					if (mOtherView.getVisibility() != View.GONE) {
						mOtherView.setVisibility(View.GONE);
					}
					if (mOtherView1.getVisibility() != View.GONE) {
						mOtherView1.setVisibility(View.GONE);
					}

				}

			}

			@Override
			public void onAnimationCancel(Animator arg0) {
				// TODO Auto-generated method stub

			}
		});
	}
	
	 
    class AnimationOther extends AnimatorListenerAdapter {

		@Override
		public void onAnimationEnd(Animator animation) {
			// TODO Auto-generated method stub
			super.onAnimationEnd(animation);
			mOtherView.setVisibility(View.GONE);
		}
    	
    }

	/**
	 * 文件夹关闭动画
	 */
	public void animateClosed() {
		if (LauncherLog.DEBUG) {
			LauncherLog.d(TAG, "animateClosed: parent = " + getParent());
		}
		if (!(getParent() instanceof DragLayer))
			return;

		int toX = 0;
		int toY = 0;
		int fromX = (int) ((to[0] - from[0]) * SCANLE_LAUNCHERBC_MAX);
		int fromY = (int) ((to[1] - from[1]) * SCANLE_LAUNCHERBC_MAX);

		LauncherFolderAnimations mFolderAnimator = new LauncherFolderAnimations(mZoomInInterpolator);

		mFolderAnimator.play(this, new float[] { 1f, 1f }, new float[] {
				SCANLE_ANIM_MI, SCANLE_ANIM_MI }, to, from);
		if(!mLauncher.getworkspace().isInSpringLoadMoed())
		mFolderAnimator.play(mWallpaperView, 0f);
		mFolderAnimator.play(mLauncherBackground,1f);

		mFolderAnimator.play(mLauncher.getFolderIconImageViewbg(), 1f);
		mFolderAnimator.setListener(new TransitionListener() {

			@Override
			public void onTransitionStart(Animator animator, Animation animation) {
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
						getContext().getString(R.string.folder_closed));
				mState = STATE_ANIMATING;
				mLauncherBackground.setLayerType(LAYER_TYPE_HARDWARE, null);
				if(!mLauncher.getworkspace().isInSpringLoadMoed())
				mWallpaperView.setVisibility(View.VISIBLE);
				mFolderName.setAlpha(0f);
			}

			@Override
			public void onTransitionEnd(Animator animator, Animation animation) {
				onCloseComplete();
				setLayerType(LAYER_TYPE_NONE, null);
				mLauncherBackground.setLayerType(LAYER_TYPE_NONE, null);
				try {
					if(mInfo.contents.size()<=0) {
						mLauncher.OnRemoveFolderIconBg();
					}
				} catch (Exception e) {
					// TODO: handle exception
				}
				mState = STATE_SMALL;
//				if(mWallpaperView.getAlpha()<=0) {
				if(!mLauncher.getworkspace().isInSpringLoadMoed()) {
					mWallpaperView.setVisibility(View.GONE);
					mWallpaperView.revert();
//					mWallpaperView.setLauncherOrgBg(null);
				}

				mLauncher.showWorkspaceSearchAndHotseat();
				expandWorkspaceAndHotseat();
				if(pagers) {
					revertFolderViews();
				}
				

			}
		});
		

		ValueAnimator alphaByThis = ObjectAnimator.ofFloat(1f, 0f);
		alphaByThis.addUpdateListener(new AnimatorUpdateListener() {

			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float percent = 1 - (float) animation.getAnimatedFraction();
				LogUtils.i(TAG, percent + "");
				if (percent <= 0.3) {
					setAlpha(percent);
				}
					if(mMoreView !=null)
					mMoreView.setAlpha(percent);

			}
		});
		int d=Utilities.getOpenFolderDuration();
		mFolderAnimator.setDuration(d);
		mFolderAnimator.setInterpolator(mZoomInInterpolator);
		mFolderAnimator.getAnimatorSet().play(alphaByThis);
		mFolderAnimator.start();
	}

	private void revertFolderViews() {
		mViewPager.removeAllViews();
		mViewPager.setVisibility(View.GONE);
		Iterator<Entry<Object, View>> it = mScrolls.entrySet().iterator();
		while (it.hasNext()) {
			Entry<Object, View> en = it.next();
			Object key = en.getKey();
			View value = en.getValue();
			Folder f = mFolders.get(key);
			if(value.getParent() ==null) {
				f.addView(value);
				f.getViewPager().setVisibility(View.GONE);
			}

		}
		mScrolls.clear();
	}
	
    /*PRIZE-folder-xiaxuefeng-2015-6-19-start*/
    private void expandWorkspaceAndHotseat() {
         PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1f);
         PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1f);
         final View parents =  mLauncher.findViewById(R.id.workspaceAndOther);
         ObjectAnimator draglayer = LauncherAnimUtils.ofPropertyValuesHolder(parents,
                 scaleX, scaleY);

         int d =Utilities.getenterEditDuration();
         draglayer.setDuration(d);
         draglayer.start();
         draglayer.addListener(new AnimatorListenerAdapter() {
         	@Override
         	public void onAnimationStart(Animator animation) {

         		parents.setLayerType(LAYER_TYPE_HARDWARE, null);
         	}
         	@Override
         	public void onAnimationEnd(Animator animation) {

         		parents.setLayerType(LAYER_TYPE_NONE, null);
         	}
         });
    }
	/*PRIZE-folder-xiaxuefeng-2015-6-19-end*/
    
//add by zhouerlong
    public boolean acceptDrop(DragObject d) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "acceptDrop: DragObject = " + d);
        }

        final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                    itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
                    !isFull());
    }

    protected boolean findAndSetEmptyCells(ShortcutInfo item) {
        int[] emptyCell = new int[2];
        if (mContent.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
            item.cellX = emptyCell[0];
            item.cellY = emptyCell[1];
            return true;
        } else {
            return false;
        }
    }
 public void loadImage(final ShortcutInfo info,final IconCache iconCache,BubbleTextView v) {
	 try {
 		v.setCompoundDrawablesWithIntrinsicBounds(
				null,
				new FastBitmapDrawable(UILimageUtil
						.getDefaultBitmap(mContext)), null, null);
     	
		} catch (Exception e) {
			// TODO: handle exception
		}
    	
		ImageLoader.getInstance().displayImage(
				info.iconUri,
				new TextViewWrapAware(v,
						mContext, iconCache),UILimageUtil.getUILoptions(mContext));
    }
    protected boolean createAndAddShortcut(ShortcutInfo item) {
        int layoutResId;
        
        try {
    		if (item.getIntent() != null
    				& item.getIntent().getComponent() != null
    				&& item.getIntent().getComponent().getClassName()
    						.equals("com.android.deskclock.DeskClock")) {
    			layoutResId = R.layout.deskclock_application;
    		} else if (item.getIntent() != null
    				& item.getIntent().getComponent() != null
    				&& (item.getIntent().getComponent().getClassName()
    						.equals("com.tencent.mm.ui.LauncherUI") || (item
    						.getIntent().getComponent().getClassName()
    						.equals("com.tencent.mobileqq.activity.SplashActivity")))) {
    			layoutResId = R.layout.wechat_application;
    		}else {
    			layoutResId=R.layout.application;
    		}
		} catch (Exception e) {
			layoutResId=R.layout.application;
		}
        final BubbleTextView textView =
                (BubbleTextView) mInflater.inflate(layoutResId, this, false);
        if(textView instanceof PrizeBubbleTextView) {
        	mLauncher.mPrizeDeskTextView = (PrizeBubbleTextView) textView;
        }
			//M by zhouerlong
//        final ResolveInfo resolveInfo = this.mContext.getPackageManager().resolveActivity(item.intent, 0);

        /** M: Modified for Unread feature. Update unread number of folder icon.@**/
        int index=-1;
        if(Launcher.isSupportClone) {
        	try {
            	index = item.intent.getAppInstanceIndex();
			} catch (Exception e) {
				// TODO: handle exception
			}
        }
        try {
            mFolderIcon.updateFolderUnreadNum(item.intent.getComponent(), item.unreadNum,item.unreadTitle,item.messageIcon,item.pendingIntent,index);

		} catch (Exception e) {
			// TODO: handle exception
		}
        /**@}**/

    	Launcher launcher = null;
    	if (mContext instanceof Launcher) {
    		 launcher = (Launcher) mContext;
    	}
    	
    	if(item.fromAppStore ==1) {
    		loadImage(item,mIconCache,textView);
		} else {
			if (Launcher.isSupportIconSize) {
				textView.setCompoundDrawablesWithIntrinsicBounds(null,
						new FastBitmapDrawable(item.getIcon(mIconCache)), null,
						null);
			} else {
				textView.setCompoundDrawables(null,
						Utilities.createIconDrawable(item.getIcon(mIconCache)),
						null, null);
			}
		}
//        	((Launcher) getContext()).dochangeWeatherIcon(textView,item);
    		

    	if(item.fromAppStore==1) {

    		textView.setProgress(item.progress);
    		 switch (item.down_state) {
			case  DownLoadService.APP_STATE_INSTALLING:
				item.title = mContext.getString(R.string.installing);
				break;
			case  DownLoadService.STATE_DOWNLOAD_WAIT:
				item.title = mContext.getString(R.string.waiting);
				break;
			case  DownLoadService.STATE_DOWNLOAD_START_LOADING:
				item.title = mContext.getString(R.string.downloading);
				break;
			case  DownLoadService.STATE_DOWNLOAD_PAUSE:
				item.title = mContext.getString(R.string.pause);
				break;

			default:
				break;
			}
    	}	
        textView.setText(item.title);
        textView.setTag(item);
        textView.setTextColor(getResources().getColor(R.color.folder_items_text_color));
        textView.setShadowsEnabled(false);

        //begin add by ouyangjin for lqtheme
        textView.setThemeChangeCallback(mFolderIcon);
        //end add by ouyangjin for lqtheme
        textView.setOnClickListener(this);
        textView.setOnLongClickListener(this);

        // We need to check here to verify that the given item's location isn't already occupied
        // by another item.
        if (mContent.getChildAt(item.cellX, item.cellY) != null || item.cellX < 0 || item.cellY < 0
                || item.cellX >= mContent.getCountX() || item.cellY >= mContent.getCountY()) {
            // This shouldn't happen, log it. 
//            Log.e(TAG, "Folder order not properly persisted during bind");
            if (!findAndSetEmptyCells(item)) {
                return false;
            }
        }

        CellLayout.LayoutParams lp =
            new CellLayout.LayoutParams(item.cellX, item.cellY, item.spanX, item.spanY);
        boolean insert = false;
        textView.setOnKeyListener(new FolderKeyEventListener());
        mContent.addViewToCellLayout(textView, insert ? 0 : -1, (int)item.id, lp, true);
        mContent.invalidate();
        return true;
    }

    public void onDragEnter(DragObject d) {
	//渐变边框  ,and 删除addicon
    	if (mContent.getChildrenLayout().indexOfChild(mAddMoreTextView) !=-1) {

            if (mAddMoreTextView != null) {
            	if (mContent.getChildrenLayout().indexOfChild(mAddMoreTextView)!=-1) {
            		mContent.removeView(mAddMoreTextView);
            	}
            }
    	}
        	openCellLayoutBgAnimation(); //玻璃效果特有的边框效果
//add by zhouerlong
        mPreviousTargetCell[0] = -1;
        mPreviousTargetCell[1] = -1;
        mOnExitAlarm.cancelAlarm();
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            realTimeReorder(mEmptyCell, mTargetCell);
        }
    };

    /**target[1] > empty[1]表示有向下拖动
     *  (target[1] == empty[1] && target[0] > empty[0])表示向右拖动
     * @param target
     * @param empty
     * @return
     */
    boolean readingOrderGreaterThan(int[] target, int[] empty) {
        if (target[1] > empty[1] || (target[1] == empty[1] && target[0] > empty[0])) {
            return true;
        } else {
            return false;
        }
    }

    private void realTimeReorder(int[] empty, int[] target) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int delay = 0;
        float delayAmount = 30;
        if (readingOrderGreaterThan(target, empty)) {
            wrap = empty[0] >= mContent.getCountX() - 1;//表示如果当前空的地方是否最右边也就是往下拖动
            startY = wrap ? empty[1] + 1 : empty[1];//true 往下移动一行开始，false 还是当前行 不会执行
            for (int y = startY; y <= target[1]; y++) {
                startX = y == empty[1] ? empty[0] + 1 : 0;//表示是往下拖动不在同一行  {y == empty[1]}true 就是同一行，fase就是下一行从0开始
                endX = y < target[1] ? mContent.getCountX() - 1 : target[0]; //{y < target[1]} true 表示有多行应该走到底 false 当前行
                for (int x = startX; x <= endX; x++) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true,null)) {
                        empty[0] = x;
                        empty[1] = y;//冒泡移动
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        } else {
            wrap = empty[0] == 0;
            startY = wrap ? empty[1] - 1 : empty[1];
            for (int y = startY; y >= target[1]; y--) {
                startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX() - 1;
                endX = y > target[1] ? 0 : target[0];
                for (int x = startX; x >= endX; x--) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true,null)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        }
    }

    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }

    public void onDragOver(DragObject d) {
    	if (mCurrentPosition !=0) {
    		mTargetFolder.onDragOver(d);
    		return;
    	}
        final DragView dragView = d.dragView;
        final int scrollOffset = mScrollView.getScrollY();
        final float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, dragView, null);
        r[0] -= getPaddingLeft();
        r[1] -= getPaddingTop();

        final long downTime = SystemClock.uptimeMillis();
        final MotionEvent translatedEv = MotionEvent.obtain(
                downTime, downTime, MotionEvent.ACTION_MOVE, d.x, d.y, 0);

        if (!mAutoScrollHelper.isEnabled()) {
            mAutoScrollHelper.setEnabled(true);
        }

        final boolean handled = mAutoScrollHelper.onTouch(this, translatedEv);
        translatedEv.recycle();

        if (handled) {
            mReorderAlarm.cancelAlarm();
        } else {
            mTargetCell = mContent.findNearestArea(
                    (int) r[0], (int) r[1] + scrollOffset, 1, 1, mTargetCell);
            if (isLayoutRtl()) {
                mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
            }
            if (mTargetCell[0] != mPreviousTargetCell[0]
                    || mTargetCell[1] != mPreviousTargetCell[1]) {
                mReorderAlarm.cancelAlarm();
                mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                mReorderAlarm.setAlarm(REORDER_DELAY);
                mPreviousTargetCell[0] = mTargetCell[0];
                mPreviousTargetCell[1] = mTargetCell[1];
                mDragMode = DRAG_MODE_REORDER;
            } else {
                mDragMode = DRAG_MODE_NONE;
            }
        }
    }

    // This is used to compute the visual center of the dragView. The idea is that
    // the visual center represents the user's interpretation of where the item is, and hence
    // is the appropriate point to use when determining drop location.
    private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
            DragView dragView, float[] recycle) {
        float res[];
        if (recycle == null) {
            res = new float[2];
        } else {
            res = recycle;
        }

        // These represent the visual top and left of drag view if a dragRect was provided.
        // If a dragRect was not provided, then they correspond to the actual view left and
        // top, as the dragRect is in that case taken to be the entire dragView.
        // R.dimen.dragViewOffsetY.
        int left = x - xOffset;
        int top = y - yOffset;

        // In order to find the visual center, we shift by half the dragRect
        res[0] = left + dragView.getDragRegion().width() / 2;
        res[1] = top + dragView.getDragRegion().height() / 2;

        return res;
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

	private DragLayer parent;
    public int getAnimationingState() {
    	return this.mState;
    }
    public void completeDragExit() {
        mLauncher.closeFolder();
       /* mCurrentDragInfo = null;
        mCurrentDragView = null;*/
        mSuppressOnAdd = false;
        mRearrangeOnClose = true;
    }

    public void onDragExit(DragObject d) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDragExit: DragObject = " + d);
        }

        // Exiting folder; stop the auto scroller.
        mAutoScrollHelper.setEnabled(false);
            this.closeCellLayoutBgAnimation(); //玻璃效果特有的边框效果

        if (mAddMoreTextView != null) {
        	if (mContent.getChildrenLayout().indexOfChild(mAddMoreTextView)==-1) {
        		mContent.addViewToCellLayout(mAddMoreTextView, -1, 0, (CellLayout.LayoutParams)mAddMoreTextView.getLayoutParams(), true);
        	}
        }
        
         
//add by zhouerlong
        // We only close the folder if this is a true drag exit, ie. not because
        // a drop has occurred above the folder.
        if (!d.dragComplete) {
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(REORDER_DELAY);
        }
        mReorderAlarm.cancelAlarm();
        mDragMode = DRAG_MODE_NONE;
    }

    public void onDropCompleted(final View target, final DragObject d,
            final boolean isFlingToDelete, final boolean success) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDropCompleted: View = " + target + ", DragObject = " + d
                    + ", isFlingToDelete = " + isFlingToDelete + ", success = " + success);
        }

        if (mDeferDropAfterUninstall) {
            Log.d(TAG, "Deferred handling drop because waiting for uninstall.");
            mDeferredAction = new Runnable() {
                    public void run() {
                        onDropCompleted(target, d, isFlingToDelete, success);
                        mDeferredAction = null;
                    }
                };
            return;
        }

        boolean beingCalledAfterUninstall = mDeferredAction != null;
        boolean successfulDrop =
                success && (!beingCalledAfterUninstall || mUninstallSuccessful);

        if (successfulDrop) {
            	mLauncher.getExplosionDialogView().setOpen(false);
            	mLauncher.getExplosionDialogView().setClose(false);
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon) {
                replaceFolderWithFinalItem();
            }
        } else {
            setupContentForNumItems(getItemCount());
            // The drag failed, we need to return the item to the folder
            mFolderIcon.onDrop(d);
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                if (!successfulDrop) {
                    mSuppressFolderDeletion = true;
                }
                completeDragExit();
            }
        }

        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
   /*     mCurrentDragInfo = null;
        mCurrentDragView = null;*/
        mSuppressOnAdd = false;

        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabaseBatch();
    }

    public void deferCompleteDropAfterUninstallActivity() {
        mDeferDropAfterUninstall = true;
    }

    public void onUninstallActivityReturned(boolean success) {
        mDeferDropAfterUninstall = false;
        mUninstallSuccessful = success;
        if (mDeferredAction != null) {
            mDeferredAction.run();
        }
    }

    @Override
    public boolean supportsFlingToDelete() {
        return true;
    }

    public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
        // Do nothing
    }

    @Override
    public void onFlingToDeleteCompleted() {
        // Do nothing
    }

    private void updateItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
        }
    }

    private void updateItemLocationsInDatabaseBatch() {
        ArrayList<View> list = getItemsInReadingOrder();
        ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            if (info !=null) {
            items.add(info);
            }
        }

        LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
    }

    public void addItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY, false);
        }
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return true;
    }


//add by zhouerlong
    private void setupContentDimensions(int count) {
        ArrayList<View> list = getItemsInReadingOrder();

        int countX = mContent.getCountX();
        int countY = mContent.getCountY();
        boolean done = false;

        while (!done) {
            int oldCountX = countX;
            int oldCountY = countY;
            if (countX * countY < count) {
                // Current grid is too small, expand it
                if (/*(countX <= countY || countY == mMaxCountY) &&*/ countX < mMaxCountX) {
                    countX++;
                } else if (countY < mMaxCountY&&countY*countX<count) {
                    countY++;
                }
                if (countY == 0) countY++;
            } else if ((countY - 1) * countX >= count /*&& countY >= countX*/) {
                countY = Math.max(0, countY - 1);
            } else if ((countX - 1) * countY >= count) {
//                countX = Math.max(0, countX - 1);
            }
            done = countX == oldCountX && countY == oldCountY;
        }
        countX=mMaxCountX;
        if (countY<mMaxCountX) {
//            countY = mMaxCountX;
        }
       /* if(countY*countX<=count) {
        	countY++;
        }*/
        mContent.setGridSize(countX, countY);
        arrangeChildren(list);
    }
   /* private void setupContentDimensions(int count) {
        ArrayList<View> list = getItemsInReadingOrder();

        int countX = mContent.getCountX();
        int countY = mContent.getCountY();
        boolean done = false;

        while (!done) {
            int oldCountX = countX;
            int oldCountY = countY;
            if (countX * countY < count) {
                // Current grid is too small, expand it
                if ((countX <= countY || countY == mMaxCountY) && countX < mMaxCountX) {
                    countX++;
                } else if (countY < mMaxCountY) {
                    countY++;
                }
                if (countY == 0) countY++;
            } else if ((countY - 1) * countX >= count && countY >= countX) {
                countY = Math.max(0, countY - 1);
            } else if ((countX - 1) * countY >= count) {
                countX = Math.max(0, countX - 1);
            }
            done = countX == oldCountX && countY == oldCountY;
        }
        mContent.setGridSize(countX, countY);
        arrangeChildren(list);
    }*/

//add by zhouerlong
    public boolean isFull() {
        return getItemCount() >= mMaxNumItems;
    }
    
    

  //add by zhouerlong
    

//add by zhouerlong
	private void centerAboutIcon(int[] from, int[] to) {
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

		parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
		int width = getPaddingLeft() + getPaddingRight()
				+ mContent.getDesiredWidth(); // 计算文件夹的宽高
		int height = (int) (getFolderHeight()+Launcher.recommdF*Launcher.scale);
//		int height = getFolderHeight();
		this.getX();// this的坐标
		this.getY();// this的坐标

		float scale = parent.getDescendantRectRelativeToSelf(
				mFolderIcon.mPreviewBackground, mTempRect);// 这个就是读取folderIcon
															// 的rect

		LauncherAppState app = LauncherAppState.getInstance();
		DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();

		int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
		int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
		int h = getFolderHeight();
		int Left = centerX - width / 2;// 差值
		int Top = centerY - h / 2;// 差值
		from[0] = Left;
		from[1] = Top;
		int currentPage = mLauncher.getWorkspace().getNextPage();
		// In case the workspace is scrolling, we need to use the final scroll
		// to compute
		// the folders bounds.
		mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
		// We first fetch the currently visible CellLayoutChildren
		View v = mLauncher.getworkspace().getChildAt(currentPage);
		
		if(!(v instanceof CellLayout)) {
			return ;
		}
		CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace()
				.getChildAt(currentPage);
		if (currentLayout == null) {
			return;
		}
		ShortcutAndWidgetContainer boundingLayout = currentLayout
				.getShortcutsAndWidgets();
		Rect bounds = new Rect();
		parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
		// We reset the workspaces scroll
		mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);

		Display display = ((Activity) this.getContext()).getWindowManager()
				.getDefaultDisplay();
		float wCenterX = (display.getWidth() - width) / 2;
		float wCenterY = (display.getHeight() - height) / 2; // add by
																// zhouerlong
																// 文件夹中心点偏上
																// 还原中心点
		to[0] = (int) wCenterX;
		to[1] = (int) wCenterY;

		int folderPivotX = (int) (mTempRect.left - wCenterX);
		int folderPivotY = (int) (mTempRect.top - wCenterY);
		mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() * (1.0f * folderPivotX / width));
		mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() * (1.0f * folderPivotY / height));
		lp.width = width;
		lp.height = (int) (height-Launcher.recommdF*Launcher.scale);
//		lp.height = height;
	}
	
    
    


//add by zhouerlong
    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    public void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        int[] from = new int[2];
        int[] to = new int[2];
        centerAboutIcon(from,to);
    }
    
    public void refreshContentHeight(int count,final int[] from,final int[] to) {

        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        centerAboutIcon(from,to);
        if(count%3==1&&count<12) {
            pushRecommdAnim(from,to);
            }
        
    }
    

	public void pushRecommdAnim(int[] from,int[] to) {
		ObjectAnimator a = ObjectAnimator.ofFloat(this, "translationY", getY(),to[1]);
		a.setDuration(800);
		a.setInterpolator(new DecelerateInterpolator());
		a.start();
	}
    

    private int getContentAreaHeight() {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        int yLine = 3;//getItemCount()%3 >0 ? getItemCount()/3 +1 :getItemCount()/3;
        Rect workspacePadding = grid.getWorkspacePadding(grid.isLandscape ?
                CellLayout.LANDSCAPE : CellLayout.PORTRAIT);
        int maxContentAreaHeight = grid.availableHeightPx -
                30* grid.edgeMarginPx -
                workspacePadding.top - workspacePadding.bottom -
                getPaddingTop() - getPaddingBottom() -
                mFolderNameHeight+Utilities.getNavigationBarHeight(mLauncher);
        if(Launcher.scale == 3){
        	maxContentAreaHeight+=80;
        }
        if(Launcher.scale == 2){
        	maxContentAreaHeight +=80;
        }
        int measureAreaHeight = yLine >=4 ? maxContentAreaHeight/3*4:maxContentAreaHeight/3*yLine;
        return Math.min(maxContentAreaHeight + mFolderNameHeight,
                mContent.getDesiredHeight());
    }

    private int getFolderHeight() { 
        int height = getPaddingTop() + getPaddingBottom()
                + getContentAreaHeight() + mFolderNameHeight; //CellLayout高度+FolderName高度
        return height;
    }

    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
        int height = getFolderHeight();
        int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(mContent.getDesiredWidth(),
                MeasureSpec.EXACTLY);
        int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(getContentAreaHeight(),
                MeasureSpec.EXACTLY);
        int contentHeight =mContent.getDesiredHeight();
        if (contentHeight==0) {
        	contentHeight = mContent.getDesiredHeightForge();
        }
        mContent.setFixedSize(mContent.getDesiredWidth(), contentHeight);
        mScrollView.measure(contentAreaWidthSpec, contentAreaHeightSpec);
        if(pagers) {
            mViewPager.measure(contentAreaWidthSpec, contentAreaHeightSpec);
        }
        mFolderName.measure(contentAreaWidthSpec,
                MeasureSpec.makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
        setMeasuredDimension(width, height);
    }

    private void arrangeChildren(ArrayList<View> list) {
        int[] vacant = new int[2];
        if (list == null) {
            list = getItemsInReadingOrder();
        }
        mContent.removeAllViews();

        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);

            if (!(v instanceof BubbleTextView)) {
                CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
                mContent.addViewToCellLayout(v, -1, 0, lp, true);
                continue;
            }
            mContent.getVacantCell(vacant, 1, 1);
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
            lp.cellX = vacant[0];
            lp.cellY = vacant[1];
            ItemInfo info = (ItemInfo) v.getTag();
            if (info.select) {
            	info.select=false;//取消的时候 还是现实勾选状态
            }
            if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
                info.cellX = vacant[0];
                info.cellY = vacant[1];
                LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
            }
            boolean insert = false;
            mContent.addViewToCellLayout(v, insert ? 0 : -1, (int)info.id, lp, true);
        }
        mItemsInvalidated = true;
    }

    public int getItemCount() {
        return mContent.getShortcutsAndWidgets().getChildCount();
    }

    public View getItemAt(int index) {
        return mContent.getShortcutsAndWidgets().getChildAt(index);
    }
    AnimTool tool=null;
    private void onCloseComplete() {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onCloseComplete: parent = " + getParent());
        }

        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
            parent.removeView(mMoreView);
            mMoreView=null;
        }

        if(tool==null) {
    		 tool = new AnimTool();
        }
		if(mLauncher.getworkspace().isInSpringLoadMoed())
		tool.starts(mLauncher.getworkspace().getCurrentLayout());
        
        mDragController.removeDropTarget((DropTarget) this);
        clearFocus();
        mFolderIcon.requestFocus();

        if (mRearrangeOnClose) {
            setupContentForNumItems(getItemCount());
            mRearrangeOnClose = false;
        }
        if (mAddMoreTextView != null) {
        	if (mContent.getChildrenLayout().indexOfChild(mAddMoreTextView)!=-1) {
        		mContent.removeView(mAddMoreTextView);
        		mAddMoreTextView = null;
        	}
        }
		//关闭的时候重新刷新界面
            setupContentForNumItems(getItemCount());
        if (getItemCount() <= 1) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
    }

    private void replaceFolderWithFinalItem() {
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screenId);

               View child = null;
                // Move the item from the folder to the workspace, in the position of the folder
                if (getItemCount() == 1) {
                	// bugId 18373  
                	if(mInfo.contents.size()>0){
                		  ShortcutInfo finalItem = mInfo.contents.get(0);
                          child = mLauncher.createShortcut(R.layout.application, cellLayout,
                                  finalItem);
                          LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                                  mInfo.screenId, mInfo.cellX, mInfo.cellY);
                	}
                }
                if (getItemCount() <= 1) {
                    // Remove the folder
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    cellLayout.removeView(mFolderIcon);
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                }
                // We add the child after removing the folder to prevent both from existing at
                // the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()
                // to ensure that hotseat items are placed correctly.
                if (child != null) {
                    mLauncher.getWorkspace().addInScreenFromBind(child, mInfo.container, mInfo.screenId,
                            mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
                }
            }
        };
        View finalChild = getItemAt(0);
        if (finalChild != null) {
            mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
        }else if (this.getItemCount() ==0){
        	onCompleteRunnable.run();
        }
        mDestroyed = true;
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    private void updateTextViewFocus() {
        View lastChild = getItemAt(getItemCount() - 1);
        getItemAt(getItemCount() - 1);
        if (lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
        }
    }

    public void onDrop(DragObject d) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDrop: DragObject = " + d);
        }

        ShortcutInfo item;
        if (d.dragInfo instanceof AppInfo) {
            // Came from all apps -- make a copy
            item = ((AppInfo) d.dragInfo).makeShortcut();
            item.spanX = 1;
            item.spanY = 1;
        } else {
            item = (ShortcutInfo) d.dragInfo;
        }

        mLauncher.getSearchBar().finishAnimations(this);
        // Dragged from self onto self, currently this is the only path possible, however
        // we keep this as a distinct code path.
        if (item == mCurrentDragInfo) {
            ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView.getLayoutParams();
            si.cellX = lp.cellX = mEmptyCell[0];
            si.cellX = lp.cellY = mEmptyCell[1];
            mContent.addViewToCellLayout(mCurrentDragView, -1, (int)item.id, lp, true);
            if (d.dragView.hasDrawn()) {
                mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, mCurrentDragView,0,true,null);
            } else {
                d.deferDragViewCleanupPostAnimation = false;
                mCurrentDragView.setVisibility(VISIBLE);
            }
            mItemsInvalidated = true;
            setupContentDimensions(getItemCount());
            mSuppressOnAdd = true;
            mInfo.add(item);
        }else {
        	if(mTargetFolder !=null)
        	mTargetFolder.onDrop(d);
//        	mTargetFolder.getInfo().add(item);
        }
    }

    // This is used so the item doesn't immediately appear in the folder when added. In one case
    // we need to create the illusion that the item isn't added back to the folder yet, to
    // to correspond to the animation of the icon back into the folder. This is
    public void hideItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        if (v != null)
        v.setVisibility(INVISIBLE);
    }
    public void showItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        if (v != null)
        v.setVisibility(VISIBLE);
    }

    public void onAdd(ShortcutInfo item) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onAdd item = " + item);
        }

        mItemsInvalidated = true;
        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        if (mSuppressOnAdd) return;
        if (!findAndSetEmptyCells(item)) {
            // The current layout is full, can we expand it?
            setupContentForNumItems(getItemCount() + 1);
            findAndSetEmptyCells(item);
        }
        createAndAddShortcut(item);
        LauncherModel.addOrMoveItemInDatabase(
                mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
        try {
            View re =  mFolderIcon.getRecommdView();
            PrizeRecommdView recommd = (PrizeRecommdView) re.findViewById(R.id.recommd);
            recommd.refresh();
		} catch (Exception e) {
			// TODO: handle exception
		}
    }
    public Workspace getWorkspace() {
    	
    	return mLauncher.getworkspace();
    }
    public void onRemove(ShortcutInfo item,FolderInfo.State state) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onRemove item = " + item);
        }

        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if(state == State.NORMAL&&mLauncher.getDragController().isDragging()) {
            if (item == mCurrentDragInfo) return;
        }
        View v = getViewForInfo(item);
        mContent.removeView(v);
        if(state ==State.NORMAL) {
            if(mCurrentDragInfo == null) return;
        }
        if (state == State.EDIT) {//当前的状态 如果是文件夹编辑状态删除icons 
        	LauncherModel.deleteItemFromDatabase(mLauncher, item);
        }
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            setupContentForNumItems(getItemCount());
        }
        if (getItemCount() <= 1&& state ==FolderInfo.State.NORMAL) {//否则只是替换而已 （此操作只有拖入脱出）
            replaceFolderWithFinalItem();
        }
    }

    public View getViewForInfo(ShortcutInfo item) {
        for (int j = 0; j < mContent.getCountY(); j++) {
            for (int i = 0; i < mContent.getCountX(); i++) {
                View v = mContent.getChildAt(i, j);
                if (v !=null) {
                    if (v.getTag() == item) {
                        return v;
                    }
                }
            }
        }
        return null;
    }
    
	public ShortcutInfo getShortcutInfoForComponentNames(ComponentName com) {
		ShortcutAndWidgetContainer layout = mContent.getShortcutsAndWidgets();
		View child = null;
		for (int i = 0; i < layout.getChildCount(); i++) {
			child = layout.getChildAt(i);
			if (child.getTag() != null) {
				Object obj = child.getTag();
				if (obj instanceof ShortcutInfo) {
					ShortcutInfo info = (ShortcutInfo) obj;
					if (info.getIntent().getComponent().equals(com)) {
						return info;
					}
				}
			}
		}

		return null;
	}
    

    public void onItemsChanged() {
        updateTextViewFocus();
    }
//此函数在编辑完成返回到folder界面时候及时刷新
	public void onItemsUpdate() {
		this.setupContentDimensions(getItemCount());
	}
    public void onTitleChanged(CharSequence title) {
    }

    public ArrayList<View> getItemsInReadingOrder() {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            for (int j = 0; j < mContent.getCountY(); j++) {
                for (int i = 0; i < mContent.getCountX(); i++) {
                    View v = mContent.getChildAt(i, j);
                    if (v != null) {
                        mItemsInReadingOrder.add(v);
                    }
                }
            }
//            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public void getLocationInDragLayer(int[] loc) {
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }
    //add by zhouerlong begin 0728--2015
	/**
	 * @param ev
	 * @param folderRect
	 * @return
	 */
	public boolean isOverLocationCellLayoutItem(MotionEvent ev,Rect folderRect) {
		for (int i = 0; i < mContent.getShortcutsAndWidgets().getChildCount(); i++) {
			View child = mContent.getShortcutsAndWidgets().getChildAt(i);
			ItemInfo info = (ItemInfo) child.getTag();

			Rect mHitRect = new Rect();
			mContent.cellToRect(info.cellX, info.cellY, info.spanX, info.spanY,
					mHitRect);

	       mLauncher.getDragLayer().getDescendantRectRelativeToSelf(child, mHitRect);
		/*	mHitRect.left+=folderRect.left;
			mHitRect.right+=folderRect.left;
			mHitRect.top+=folderRect.top;
			mHitRect.bottom+=folderRect.top;*/
			

			if (mHitRect.contains((int) ev.getX(), (int) ev.getY())&&folderRect.contains((int) ev.getX(), (int) ev.getY()) ) {
				return true;
			}

		}
		return false;
	}
    //add by zhouerlong begin 0728 --2015

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName) {
        	if (hasFocus) {
        		startEditingFolderName();
            	PrizeSwitchView psw = (PrizeSwitchView) mFolderIcon.getSwitchView();
            	start();
            	psw.open();
//        		mFolderName.setBackground(
//        				mContext.getDrawable(R.drawable.folder_name_style));
        		
        	} else {
        		mFolderName.setBackgroundColor(Color.TRANSPARENT);
        	}
        }
    }

 /**
     * M: Update unread number of the content shortcut.
     */
    public void updateContentUnreadNum() {
        if (LauncherLog.DEBUG_UNREAD) {
            LauncherLog.d(TAG, "Folder updateContentUnreadNum: mInfo = " + mInfo);
        }
        ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer)mContent.getShortcutsAndWidgets();
        int childCount = container.getChildCount();
        for(int i=0;i<childCount;i++){
            BubbleTextView shortcut = (BubbleTextView) container.getChildAt(i);
            if (shortcut != null) {
                shortcut.invalidate();
            }
        }
    }/**
     * M: Update unread number of the content shortcut.
     */
    public void updateContentDownload(DownLoadTaskInfo dinfo) {
        if (LauncherLog.DEBUG_UNREAD) {
            LauncherLog.d(TAG, "Folder updateContentUnreadNum: mInfo = " + mInfo);
        }
        ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer)mContent.getShortcutsAndWidgets();
        int childCount = container.getChildCount();
        for(int i=0;i<childCount;i++){
            BubbleTextView shortcut = (BubbleTextView) container.getChildAt(i);
           ItemInfo info = (ItemInfo) shortcut .getTag();
            if(info.packageName!=null&&info.packageName.equals(dinfo.pkgName)) 
            {

            	PrizePlayView target = (PrizePlayView) shortcut;
            	String title="";
                if(info.down_state == DownLoadService.APP_STATE_INSTALLING) {
                	title = mContext.getString(R.string.installing);
                    target.setText(title);
                	
                }else if(info.down_state == DownLoadService.STATE_DOWNLOAD_WAIT) {
                	title = mContext.getString(R.string.waiting);
                    target.setText(title);
                	
                }else if(info.down_state == DownLoadService.STATE_DOWNLOAD_START_LOADING){
//                	title = "下载中";
                  	title = mContext.getString(R.string.downloading);
                  	LogUtils.i("zhouerlong", "下载中。。。。folder。。"+info.down_state+"   进度::::"+info.progress);
                    target.setText(title);
                    target.start();
                }else if(info.down_state == DownLoadService.STATE_DOWNLOAD_PAUSE){
                	LogUtils.i("zhouerlong", "暂停。。。。folder。。"+info.down_state+"   进度::::"+info.progress);
//                	title = "暂停";
                  	title = mContext.getString(R.string.pause);
                    target.setText(title);
                    target.stop();
                }
                update(target,dinfo);
            
            }
        }
    }
    
    
    
    /**
     * M: Update unread number of the content shortcut.
     */
    public ItemInfo findContentDownloadItem(String pkg) {
        if (LauncherLog.DEBUG_UNREAD) {
            LauncherLog.d(TAG, "Folder updateContentUnreadNum: mInfo = " + mInfo);
        }
        ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer)mContent.getShortcutsAndWidgets();
        int childCount = container.getChildCount();
        for(int i=0;i<childCount;i++){
            BubbleTextView shortcut = (BubbleTextView) container.getChildAt(i);
           ItemInfo info = (ItemInfo) shortcut .getTag();
            if(info.packageName!=null&&info.packageName.equals(pkg)) 
            {
            	return info;
            }
        }
        return null;
    }
    
    
    /**
     * M: Update unread number of the content shortcut.
     */
    public void updateContentDownload(String  pkg) {
        if (LauncherLog.DEBUG_UNREAD) {
            LauncherLog.d(TAG, "Folder updateContentUnreadNum: mInfo = " + mInfo);
        }
        ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer)mContent.getShortcutsAndWidgets();
        int childCount = container.getChildCount();
        for(int i=0;i<childCount;i++){
            BubbleTextView shortcut = (BubbleTextView) container.getChildAt(i);
           ItemInfo info = (ItemInfo) shortcut .getTag();
            if(info.packageName!=null&&info.packageName.equals(pkg)) 
            {
            	
            }
        }
    }
    
    void update(final PrizePlayView target,final DownLoadTaskInfo dInfo) {
  	  mHandler.post(new Runnable() {
			
			@Override
			public void run() {
				if(target!=null) {
	  				target.setDownLoadState(dInfo.state);
	  				target.setProgress(dInfo.progress);
				}
			}
		});
  }
    /**
     * M: Update unread number of the content shortcut.
     * @return 
     */
	public View findViewForComponentName(ComponentName component) {
		if (LauncherLog.DEBUG_UNREAD) {
			LauncherLog.d(TAG, "Folder updateContentUnreadNum: mInfo = "
					+ mInfo);
		}
		ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer) mContent
				.getShortcutsAndWidgets();
		int childCount = container.getChildCount();
		for (int i = 0; i < childCount; i++) {
			View child = container.getChildAt(i);
			Object obj = child.getTag();
			if (obj instanceof ShortcutInfo) {
				ShortcutInfo info = (ShortcutInfo) obj;

				if (info.getIntent() != null
						&& info.getIntent().getComponent() != null
						&& info.getIntent().getComponent().equals(component)) {
					return child;
				}
			}
		}
		return null;
	}


    @Override
    public void getHitRectRelativeToDragLayer(Rect outRect) {
        getHitRect(outRect);
    }
	@Override
	public void onFristEnter(DragObject dragObject) {
		
	}
	
	
	class BlurTask extends AsyncTask<Bitmap, Void, Drawable> {
		
		private long time;

		@Override
		protected void onPostExecute(Drawable result) {
			
			super.onPostExecute(result);
			blurBackground(result);
	    	Log.i("zhouerlong", "耗时:"+(SystemClock.uptimeMillis()-time));
		}

		@Override
		protected Drawable doInBackground(Bitmap... params) {
			Bitmap screen = null;
			try {

				 screen = getScreenView(params[0]);
			} catch (Exception e) {
				// TODO: handle exception
			}
	    	 time = SystemClock.uptimeMillis();
			Bitmap blurScreen = ImageUtils.blurScale(screen,3.8f);
			if (screen != null ) {
				screen.recycle();
	        	System.gc();
			}

	    	final Drawable bac_launcher = new BitmapDrawable(blurScreen);
			return bac_launcher;
		}
		
	}
	/*PRIZE-folder-xiaxuefeng-2015-6-19-start*/
    public void blurBackground(Drawable bac_launcher) {
//    	final Drawable bac_launcher = new BitmapDrawable(blurScale(getScreenView()));
    	mWallpaperView.setLauncherBg(bac_launcher,null);
    	mWallpaperView.invalidate();
    	mWallpaperView.setVisibility(View.VISIBLE);
		//add by zhouerlong 
    	ObjectAnimator launcherBackground = ObjectAnimator.ofFloat(mWallpaperView,"alpha", 0f, 1f);
    	/*ObjectAnimator launcherBackground = LauncherAnimUtils.ofPropertyValuesHolder(mLauncherBackground,
    			alpha);*/
    	launcherBackground.setDuration(500);
    	launcherBackground.start();
    	launcherBackground.addListener(new AnimatorListener() {
			
			@Override
			public void onAnimationStart(Animator animation) {
				// TODO Auto-generated method stub
				mWallpaperView.
                setLayerType(LAYER_TYPE_HARDWARE, null);
			}
			
			@Override
			public void onAnimationRepeat(Animator animation) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void onAnimationEnd(Animator animation) {
				// TODO Auto-generated method stub

				mWallpaperView.
                setLayerType(LAYER_TYPE_NONE, null);
				mWallpaperView.setAlpha(1f);
			}
			
			@Override
			public void onAnimationCancel(Animator animation) {
				// TODO Auto-generated method stub
				
			}
		});
	}
    
    
    /*PRIZE-folder-xiaxuefeng-2015-6-19-start*/
    public void blurBackgrounds(Drawable bac_launcher) {
//    	final Drawable bac_launcher = new BitmapDrawable(blurScale(getScreenView()));
    	mWallpaperView.setLauncherBg(bac_launcher,null);
    	mWallpaperView.invalidate();
    	mWallpaperView.setVisibility(View.VISIBLE);
		mLauncher.hideWorkspaceSearchAndHotseat();//add by xiaxuefeng
	}
	
	private Bitmap getScreenView(Bitmap	launcherView) {
		final View parents =  mLauncher.findViewById(R.id.drag_layer);
	        //上面2行必须加入，如果不加如view.getDrawingCache()返回null
		
	
		Drawable bgd = mLauncher.getWallpaper();
		Drawable[] array = new Drawable[2];
		array[0] = bgd;
		array[1] = ImageUtils.bitmapToDrawable(launcherView);
		int windowWidth = mLauncher.getWindow().getDecorView().getWidth();
		int windowHeight = mLauncher.getWindow().getDecorView().getHeight();
		int offsetX = (int) (windowWidth * 0.1);
		int offsetY = (int) (windowHeight * 0.1);
		LayerDrawable ld = new LayerDrawable(array);
		ld.setLayerInset(1, offsetX, offsetY, offsetX, offsetY);
		return ImageUtils.drawableToBitmap1(ld);
	}
	
	private void shrinkWorkspaceAndHotseat() {
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0.8f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0.8f);
        final View parents =  mLauncher.findViewById(R.id.workspaceAndOther);
        ObjectAnimator draglayer = LauncherAnimUtils.ofPropertyValuesHolder(parents,
                scaleX, scaleY);


		int d=Utilities.getenterEditDuration();
        draglayer.setDuration(d);
        draglayer.start();
        draglayer.addListener(new AnimatorListenerAdapter() {
        	@Override
        	public void onAnimationStart(Animator animation) {

        		parents.setLayerType(LAYER_TYPE_HARDWARE, null);
        		parents.setVisibility(View.VISIBLE);
        	}
        	@Override
        	public void onAnimationEnd(Animator animation) {

        		parents.setLayerType(LAYER_TYPE_NONE, null);
        		mLauncher.hideWorkspaceSearchAndHotseat();//add by xiaxuefeng
        	}
        });
        draglayer.addUpdateListener(new AnimatorUpdateListener() {
			
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float updateValue = (float) animation.getAnimatedValue()-0.8f;
				Log.i("zhouerlong", "updateValue :::"+updateValue);
				parents.setAlpha(updateValue*255);
				
			}
		});
	}
    
    
    
    
	/*PRIZE-folder-xiaxuefeng-2015-6-19-end*/
	@Override

	public void onStartMuitipleDrag(View child, DragObject dragobject,
			Runnable exitSpringLoadedRunnable,View dragChild) {		// TODO Auto-generated method stub
		
	}
	
	private Folder mTargetFolder;
	private int mCurrentPosition=0;
	@Override
	public void onPageSelected(int position) {
		mCurrentPosition = position;
		TextView t=(TextView)mMoreView.getChildAt(mCurrentPosition);
		mFolderName.setText(t.getText().toString());
		mTargetFolder = mFolders.get(mMoreView.getChildAt(mCurrentPosition).getTag());
		
	}
	/*@Override
	public void beforeTextChanged(CharSequence s, int start, int count,
			int after) {
		if(null != mFolderName.getText() &&  mFolderName.getText().toString().length()==6 && mIsEditingName){
			Toast.makeText(mLauncher, R.string.folder_name_toast, 1200).show();
		}
		
	}
	@Override
	public void onTextChanged(CharSequence s, int start, int before, int count) {
		
	}
	@Override
	public void afterTextChanged(Editable s) {
		if(null != mFolderName.getText() &&  mFolderName.getText().toString().length()==6 && mIsEditingName){
			Toast.makeText(mLauncher, R.string.folder_name_toast, 1200).show();
		}
	}*/
	@Override
	public void afterTextChanged(Editable arg0) {
		LogUtils.i("zhouerlong", "sdf");
		
	}
	@Override
	public void beforeTextChanged(CharSequence arg0, int arg1, int arg2,
			int arg3) {
		LogUtils.i("zhouerlong", "sdf");
		
	}
	@Override
	public void onTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {
		LogUtils.i("zhouerlong", "sdf");
		
	}
}